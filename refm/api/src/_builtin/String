= class String < Object

include Comparable

文字列のクラスです。
ヌル文字を含む任意のバイト列を扱うことができます。
文字列の長さにはメモリ容量以外の制限はありません。

文字列は通常、文字列リテラルを使って生成します。
以下に文字列リテラルの例をいくつか示します。

#@samplecode 文字列リテラルの例
'str\\ing'   # シングルクオート文字列 (エスケープシーケンスがほぼ無効)
"string\n"   # ダブルクオート文字列 (エスケープシーケンスがすべて有効)
%q(str\\ing) # 「%q」文字列 (エスケープシーケンスがほぼ無効、デリミタが変えられる)
%Q(string\n) # 「%Q」文字列 (エスケープシーケンスがすべて有効、デリミタが変えられる)

# ヒアドキュメント
<<End
この行はヒアドキュメント
End

# ダブルクオートヒアドキュメント (クオートなしの場合と同じ)
<<"End"
この行はヒアドキュメント
End

# シングルクオートヒアドキュメント (一切のエスケープシーケンスが無効)
<<'End'
この行はヒアドキュメント
End

# 終端記号がインデントされたヒアドキュメント
# シングルクオート、ダブルクオートとの併用も可能
<<-End
この行はヒアドキュメント (終端記号をインデントできる)
   End

#@since 2.3.0
# 中身がインデントされたヒアドキュメント
# シングルクオート、ダブルクオートとの併用も可能
<<~End
  この行のインデントは無視される
End
#@end
#@end

===[a:mutable] 破壊的な変更

Ruby の String クラスは mutable です。
つまり、オブジェクト自体を破壊的に変更できます。

「破壊的な変更」とは、あるオブジェクトの内容自体を変化させることです。
例えば文字列のすべての文字を破壊的に大文字へ変更する
[[m:String#upcase!]] メソッドの使用例を以下に示します。

#@samplecode 例:String#upcase!
a = "string"
b = a
a.upcase!
p a   # => "STRING"
p b   # => "STRING"
#@end

この例では、a に対してメソッドを呼んだにも関わらず b も変更されています。
これは、変数 a と b が一つの文字列オブジェクトを指していて、
upcase! メソッドでそのオブジェクト自体が変更されたからです。

upcase! の非破壊版である [[m:String#upcase]] を使った例を以下に示します。
こちらでは a の変更が b に波及しません。

#@samplecode 例:String#upcase
a = "string"
b = a
a = a.upcase
p a   # => "STRING"
p b   # => "string"
#@end

一般には、破壊的「ではない」メソッドを
中心に使っていくほうがバグが出にくくなります。

String クラスのメソッドには破壊的なメソッドも非破壊的なメソッドもあります。
破壊的なメソッドの例としては concat, sub!, upcase! などが挙げられます。
非破壊的なメソッドの例としては index, sub, upcase などが挙げられます。

同じ動作で破壊的なメソッドと非破壊的なメソッドの両方が定義されているときは、
破壊的なバージョンには名前の最後に「!」が付いています。
例えば upcase メソッドは非破壊的で、upcase! メソッドは破壊的です。

ただし、この命名ルールを
「破壊的なメソッドにはすべて『!』が付いている」と解釈しないでください。
例えば concat には「!」が付いていませんが、破壊的です。あくまでも、
「『!』が付いているメソッドと付いていないメソッドの両方があるときは、
『!』が付いているほうが破壊的」というだけです。
「『!』が付いているならば破壊的」は常に成立しますが、逆は必ずしも成立しません。

===[a:m17n] 多言語化と文字列のエンコーディング

String オブジェクトは自身のエンコーディング情報を持ちます。
インスタンスメソッドはエンコーディングに従い、1バイトではなく1文字を単位として動作します。
エンコーディングの変換にはメソッド [[m:String#encode]] を使います。

#@samplecode 例:エンコーディングの変換
p "いろは".size      #=> 3 
p "漢字"[0]          #=> "漢"
p "山本山".reverse   #=> "山本山" (回文なので分からないですね)
p "ループ".reverse   #=> "プール"

s = "ruビー"
s[0..1] = "ル" 
p s                  #=> "ルビー"

e = "言語".encode("EUC-JP")
u = "言語".encode("UTF-8")
p e.encoding                   #=> Encoding::EUC_JP
p u.encoding                   #=> Encoding::UTF_8
#@end

より詳しく知りたい場合は、[[d:spec/m17n]] を参照してください。

==== 文字列同士の比較・結合

文字列同士の比較・結合などでは両者のエンコーディングを意識する必要があります。
例えば [[m:String#==]] や [[m:String#eql?]] は両者のエンコーディングが等しく
バイト列表現が等しい場合にのみ true を返します。
このときエンコーディングが UTF-8 であっても正規化せずに比較します。
文字列の結合も同様です。異なるエンコーディング同士の文字列を結合する時は
明示的にエンコーディングを変換する必要があります。

#@samplecode 例:文字列の結合
s = "いろは"
a = s.encode("EUC-JP")
b = s.encode("UTF-8")
p a == b                            #=> false

s = "合".encode("EUC-JP")
p s + "\u{4f53}".encode("EUC-JP")   #=> "合体"
p s + "\u{4f53}"                    #=> Encoding::CompatibilityError
#@end

[[m:String#eql?]] はハッシュのキーの比較に使われますので、
ハッシュのキーに非 ASCII 文字列を使う場合には注意が必要です。

#@samplecode 動作例:  (注)一行目にmagic commentが必要です。
# encoding: UTF-8
h = {}
s = "いろは"
s.force_encoding("EUC-JP")
h[s] = 1
s.force_encoding("ASCII-8BIT")
p h[s]                             #=> nil
#@end

==== 7bit クリーンな文字列

ASCII 互換エンコーディングをもつ 7bit クリーンな文字列は
エンコーディングに関わらず ASCII として扱うことができます。
例えば [[m:String#==]] は両者の文字エンコーディングが異なっていても
true を返します。
ASCII 互換エンコーディングをもつ文字列にエンコーディングの変換なしで結合することができます。

#@samplecode 例:
  s = "abc"
  a = s.encode("EUC-JP")
  b = s.encode("UTF-8")
  p a == b                           #=> true
  p a + b                            #=> "abcabc"
#@end

ここで言う「ASCII互換エンコーディング」とは、コードポイントが同一という意味ではなく
バイト列が同じことを意味します。従って UTF-16 はASCII互換ではありません。
また厳密性を追求せず、おおむね互換なら互換と呼びます。よって Shift_JIS は ASCII 互換です。

==== バイト列を表す文字列

文字列ではない単なるバイト列も String オブジェクトで表されます。
その時のエンコーディングは ASCII-8BIT です。

== Class Methods

--- try_convert(obj) -> String | nil

obj を String に変換しようと試みます。変換には [[m:Object#to_str]] メソッ
ドが使われます。変換後の文字列を返すか、何らかの理由により変換できなかっ
た場合は nil が返されます。

@param obj   変換する任意のオブジェクト
@return      変換後の文字列または nil

#@samplecode 例
   String.try_convert("str")     # => "str"
   String.try_convert(/re/)      # => nil
#@end

--- new(string = "")                -> String
#@if("2.3.0" <= version and version < "2.4.0")
--- new(string = "", encoding: string.encoding) -> String
#@end
#@since 2.4.0
#@# 127 は STR_BUF_MIN_SIZE。string.c 参照。
--- new(string = "", encoding: string.encoding, capacity: 127) -> String
--- new(string = "", encoding: string.encoding, capacity: string.bytesize) -> String
#@end

string と同じ内容の新しい文字列を作成して返します。
引数を省略した場合は空文字列を生成して返します。

@param string   文字列
#@since 2.3.0
@param encoding 作成する文字列のエンコーディングを文字列か
                [[c:Encoding]] オブジェクトで指定します(変換は行われま
                せん)。省略した場合は引数 string のエンコーディングと同
                じになります(ただし、string が指定されていなかった場合は
                [[m:Encoding::ASCII_8BIT]]になります)。
#@end
#@since 2.4.0
@param capacity 内部バッファのサイズを指定します。
                指定することで、なんども文字列連結する
                (そしてreallocがなんども呼ばれる)ときの
                パフォーマンスが改善されるかもしれません。
                省略した場合、引数stringのバイト数が127未満であれば127、
                それ以上であればstring.bytesizeになります。
#@end
@return         引数 string と同じ内容の文字列オブジェクト

#@samplecode 例
text = "hoge".encode("EUC-JP")
no_option = String.new(text)                             # => "hoge"
no_option.encoding == Encoding::EUC_JP                   # => true
#@since 2.3.0
with_encoding = String.new(text, encoding: "UTF-8")      # => "hoge"
with_encoding.encoding == Encoding::UTF_8                # => true
#@end
#@since 2.4.0
String.new("test", encoding: "UTF-8", capacity: 100_000) # => "test"
#@end
#@end

== Instance Methods

#@since 2.3.0
--- +@ -> String | self

self が freeze されている文字列の場合、元の文字列の複製を返します。
freeze されていない場合は self を返します。

#@samplecode 例
# frozen_string_literal: false
original_text = "text"
unfrozen_text = +original_text
original_text == unfrozen_text      # => true
original_text.equal?(unfrozen_text) # => true

frozen_text = "text".freeze
unfrozen_text = +frozen_text
frozen_text == unfrozen_text        # => true
frozen_text.equal?(unfrozen_text)   # => false
#@end

@see [[m:String#-@]]

--- -@ -> String | self

self が freeze されている文字列の場合、self を返します。
freeze されていない場合は元の文字列の freeze された (できる限り既存の) 複製を返します。

#@samplecode 例
# frozen_string_literal: false
original_text = "text"
unfrozen_text = -original_text
original_text == unfrozen_text      # => true
original_text.equal?(unfrozen_text) # => false

frozen_text = "text".freeze
unfrozen_text = -frozen_text
frozen_text == unfrozen_text        # => true
frozen_text.equal?(unfrozen_text)   # => true
#@end

@see [[m:String#+@]]
#@end

--- +(other) -> String

文字列と other を連結した新しい文字列を返します。

@param other    文字列
@return         self と other を連結した文字列

#@samplecode 例
p "str" + "ing"   # => "string"

a = "abc"
b = "def"
p a + b   # => "abcdef"
p a       # => "abc"  (変化なし)
p b       # => "def"
#@end

--- *(times) -> String

文字列の内容を times 回だけ繰り返した新しい文字列を作成して返します。

@param times    整数
@return         self を times 回繰り返した新しい文字列

@raise ArgumentError 引数に負数を指定したときに発生します。

#@samplecode 例
p "str" * 3   # => "strstrstr"

str = "abc"
p str * 4   # => "abcabcabcabc"
p str * 0   # => ""
p str       # => "abc"  (変化なし)
#@end

--- %(args) -> String

printf と同じ規則に従って args をフォーマットします。

args が配列であれば [[m:Kernel.#sprintf]](self, *args) と同じです。
それ以外の場合は [[m:Kernel.#sprintf]](self, args) と同じです。

@param args     フォーマットする値、もしくはその配列
@return         フォーマットされた文字列

#@samplecode 例
p "i = %d" % 10       # => "i = 10"
p "i = %x" % 10       # => "i = a"
p "i = %o" % 10       # => "i = 12"

p "i = %#d" % 10      # => "i = 10"
p "i = %#x" % 10      # => "i = 0xa"
p "i = %#o" % 10      # => "i = 012"

p "%d" % 10           # => "10"
p "%d,%o" % [10, 10]  # => "10,12"
#@end

#@include(printf-format)

--- <=>(other) -> -1 | 0 | 1 | nil

self と other を ASCII コード順で比較して、
self が大きい時には 1、等しい時には 0、小さい時には -1 を返します。
このメソッドは Comparable モジュールのメソッドを実装するために使われます。

other が文字列でない場合、
other.to_str と other.<=> が定義されていれば
0 - (other <=> self) の結果を返します。
そうでなければ nil を返します。

@param other    文字列
@return         比較結果の整数か nil

#@samplecode 例
p "aaa" <=> "xxx"   # => -1
p "aaa" <=> "aaa"   # => 0
p "xxx" <=> "aaa"   # => 1

p "string" <=> "stringAA"  # => -1
p "string" <=> "string"    # => 0
p "stringAA" <=> "string"  # => 1
#@end

--- ==(other) -> bool
--- ===(other) -> bool

other が文字列の場合、[[m:String#eql?]] と同様に文字列の内容を比較します。

other が文字列でない場合、
other.to_str が定義されていれば
other == self の結果を返します。(ただし、 other.to_str は実行されません。)
そうでなければ false を返します。

@param other    任意のオブジェクト
@return         true か false

#@samplecode 例
stringlike = Object.new

def stringlike.==(other)
  "string" == other
end

p "string".eql?(stringlike) #=> false
p "string" == stringlike    #=> false

def stringlike.to_str
  raise
end

p "string".eql?(stringlike) #=> false
p "string" == stringlike    #=> true
#@end

@see [[m:String#eql?]]

--- <<(other) -> self
--- concat(other) -> self

self に文字列 other を破壊的に連結します。
other が 整数である場合は other.chr(self.encoding) 相当の文字を末尾に追加します。

self を返します。

@param other    文字列もしくは 0 以上の整数

#@samplecode 例
str = "string"
str.concat "XXX"
p str    # => "stringXXX"

str << "YYY"
p str    # => "stringXXXYYY"

str << 65  # 文字AのASCIIコード
p str    # => "stringXXXYYYA"
#@end

#@since 2.4.0
--- concat(*arguments) -> self

self に複数の文字列を破壊的に連結します。

引数の値が整数である場合は [[m:Integer#chr]] の結果に相当する文字を末尾に追加します。追加する文字のエンコーディングは self.encoding です。

self を返します。

@param arguments 複数の文字列もしくは 0 以上の整数

#@samplecode 例
str = "foo"
str.concat
p str    # => "foo"

str = "foo"
str.concat "bar", "baz"
p str    # => "foobarbaz"

str = "foo"
str.concat("!", 33, 33)
p str    # => "foo!!!"
#@end
#@end

--- =~(other) -> Integer

正規表現 other とのマッチを行います。
マッチが成功すればマッチした位置のインデックスを、そうでなければ nil を返します。

other が正規表現でも文字列でもない場合は
other =~ self を行います。

このメソッドが実行されると、組み込み変数 [[m:$~]], [[m:$1]], ...
にマッチに関する情報が設定されます。

@param other        正規表現もしくは =~ メソッドを持つオブジェクト
@raise TypeError    other が文字列の場合に発生します。

#@samplecode 例
p "string" =~ /str/   # => 0
p "string" =~ /not/   # => nil
p "abcfoo" =~ /foo/   # => 3
#@end

--- [](nth) -> String | nil
--- slice(nth) -> String | nil

nth 番目の文字を返します。
nth が負の場合は文字列の末尾から数えます。
つまり、 self.size + nth 番目の文字を返します。

nth が範囲外を指す場合は nil を返します。

@param nth 文字の位置を表す整数
@return 指定した位置の文字を表す String オブジェクト

#@samplecode 例
p 'bar'[2]       # => "r"
p 'bar'[2] == ?r # => true
p 'bar'[-1]      # => "r"
p 'bar'[3]       # => nil
p 'bar'[-4]      # => nil
#@end

このメソッドの仕様は 1.8.x 以前から大きく変更されていますので注意が必要
です。

--- [](nth, len) -> String | nil
--- slice(nth, len) -> String | nil

nth 文字目から長さ len 文字の部分文字列を新しく作って返します。
nth が負の場合は文字列の末尾から数えます。

@param nth    取得したい文字列の開始インデックスを整数で指定します。
@param len    取得したい文字列の長さを正の整数で指定します。

@return nth が範囲外を指す場合は nil を返します。

#@samplecode 例
str0 = "bar"
str0[2, 1]         #=> "r"
str0[2, 0]         #=> ""
str0[2, 100]       #=> "r"  (右側を超えても平気)
str0[-1, 1]        #=> "r"
str0[-1, 2]        #=> "r"  (右に向かって len 文字)

str0[3, 1]         #=> ""
str0[4, 1]         #=> nil
str0[-4, 1]        #=> nil
str1 = str0[0, 2]    # (str0 の「一部」を str1 とする)
str1               #=> "ba"
str1[0] = "XYZ"
str1               #=> "XYZa" (str1 の内容が破壊的に変更された)
str0               #=> "bar" (str0 は無傷、 str1 は str0 と内容を共有していない)
#@end

--- [](substr) -> String | nil
--- slice(substr) -> String | nil

self が substr を含む場合、一致した文字列を新しく作って返します。
substr を含まなければ nil を返します。

@param substr    取得したい文字列のパターン。文字列

#@samplecode 例
substr = "bar"
result = "foobar"[substr]
p result   # => "bar"
p substr.equal?(result)   # => false
#@end

--- [](regexp, nth = 0) -> String
--- slice(regexp, nth = 0) -> String

正規表現 regexp の nth 番目の括弧にマッチする最初の部分文字列を返します。
nth を省略したときや 0 の場合は正規表現がマッチした部分文字列全体を返します。
正規表現が self にマッチしなかった場合や nth に対応する括弧がないときは nil を返します。

このメソッドを実行すると、
マッチ結果に関する情報が組み込み変数 [[m:$~]] に設定されます。

@param regexp    取得したい文字列のパターンを示す正規表現
@param nth       取得したい正規表現レジスタのインデックス。整数

#@samplecode 例
p "foobar"[/bar/]  # => "bar"
p $~.begin(0)      # => 3
p "def getcnt(line)"[ /def\s+(\w+)/, 1 ]   # => "getcnt"
#@end

--- [](regexp, name) -> String
--- slice(regexp, name) -> String

正規表現 regexp の name で指定した名前付きキャプチャにマッチする最初の
部分文字列を返します。正規表現が self にマッチしなかった場合は nil を返
します。

@param regexp 正規表現を指定します。
@param name 取得したい部分文字列のパターンを示す正規表現レジスタを示す名前

@raise IndexError name に対応する括弧がない場合に発生します。

#@samplecode 例
s = "FooBar"
s[/(?<foo>[A-Z]..)(?<bar>[A-Z]..)/]        # => "FooBar"
s[/(?<foo>[A-Z]..)(?<bar>[A-Z]..)/, "foo"] # => "Foo"
s[/(?<foo>[A-Z]..)(?<bar>[A-Z]..)/, "bar"] # => "Bar"
s[/(?<foo>[A-Z]..)(?<bar>[A-Z]..)/, "baz"] # => IndexError
#@end

--- [](range) -> String
--- slice(range) -> String

rangeで指定したインデックスの範囲に含まれる部分文字列を返します。

@param range   取得したい文字列の範囲を示す Range オブジェクト

=== rangeオブジェクトが終端を含む場合

インデックスと文字列の対応については以下の対照図も参照してください。

    0   1   2   3   4   5   (インデックス)
   -6  -5  -4  -3  -2  -1   (負のインデックス)
  | a | b | c | d | e | f |
  |<--------->|                'abcdef'[0..2]  # => 'abc'
                  |<----->|    'abcdef'[4..5]  # => 'ef'
          |<--------->|        'abcdef'[2..4]  # => 'cde'

range.last が文字列の長さ以上のときは
(文字列の長さ - 1) を指定したものとみなされます。

range.first が 0 より小さいか文字列の長さより大きいときは nil を
返します。ただし range.first および range.last のどちらか
または両方が負の数のときは一度だけ文字列の長さを足して
再試行します。

#@samplecode 例
'abcd'[ 2 ..  1] # => ""
'abcd'[ 2 ..  2] # => "c"
'abcd'[ 2 ..  3] # => "cd"
'abcd'[ 2 ..  4] # => "cd"

'abcd'[ 2 .. -1] # => "cd"   # str[f..-1] は「f 文字目から
'abcd'[ 3 .. -1] # => "d"    # 文字列の最後まで」を表す慣用句

'abcd'[ 1 ..  2] # => "bc"
'abcd'[ 2 ..  2] # => "c"
'abcd'[ 3 ..  2] # => ""
'abcd'[ 4 ..  2] # => ""
'abcd'[ 5 ..  2] # => nil

'abcd'[-3 ..  2] # => "bc"
'abcd'[-4 ..  2] # => "abc"
'abcd'[-5 ..  2] # => nil
#@end

=== rangeオブジェクトが終端を含まない場合

文字列と「隙間」の関係については以下の模式図を参照してください。

     0   1   2   3   4   5   6  (隙間番号)
    -6  -5  -4  -3  -2  -1      (負の隙間番号)
     | a | b | c | d | e | f |
     |<--------->|                'abcdef'[0...3]  # => 'abc'
                     |<----->|    'abcdef'[4...6]  # => 'ef'
             |<--------->|        'abcdef'[2...5]  # => 'cde'

range.last が文字列の長さよりも大きいときは文字列の長さを
指定したものとみなされます。

range.first が 0 より小さいか文字列の長さより大きいときは nil を返します。
ただし range.first と range.last のどちらかまたは両方が負の数
であるときは一度だけ文字列の長さを足して再試行します。

#@samplecode 例
'abcd'[ 2 ... 3] # => "c"
'abcd'[ 2 ... 4] # => "cd"
'abcd'[ 2 ... 5] # => "cd"

'abcd'[ 1 ... 2] # => "b"
'abcd'[ 2 ... 2] # => ""
'abcd'[ 3 ... 2] # => ""
'abcd'[ 4 ... 2] # => ""
'abcd'[ 5 ... 2] # => nil

'abcd'[-3 ... 2] # => "b"
'abcd'[-4 ... 2] # => "ab"
'abcd'[-5 ... 2] # => nil
#@end

--- []=(nth, val)

nth 番目の文字を文字列 val で置き換えます。

@param nth 置き換えたい文字の位置を指定します。
@param val 置き換える文字列を指定します。

@return val を返します。

#@samplecode 例
buf = "string"
buf[1] = "!!"
p buf   # => "s!!ring"
#@end

--- []=(nth, len, val)

nth 番目の文字から len 文字の部分文字列を文字列 val で置き換えます。

len が0 の場合は、単にnthの位置から文字列の追加が行われます。
nth が負の場合は文字列の末尾から数えます。

@param nth    置き換えたい部分文字列の開始インデックス
@param len    置き換えたい部分文字列の長さ
@param val    指定範囲の部分文字列と置き換える文字列

@return val を返します。

#@samplecode 例
buf = "string"
buf[1, 4] = "!!"
p buf   # => "s!!g"

buf = "string"
buf[1, 0] = "!!"
p buf   # => "s!!tring"
#@end

--- []=(substr, val)

文字列中の substr に一致する最初の部分文字列を文字列 val で置き換えます。

@param substr    置き換えたい部分文字列のパターンを示す文字列
@param val       指定範囲の部分文字列と置き換える文字列

@return val を返します。

@raise IndexError    self が部分文字列 substr を含まない場合に発生します。

#@samplecode 例
buf = "string"
buf["trin"] = "!!"
p buf   # => "s!!g"

buf = "string"
buf["nosuchstring"] = "!!"   # IndexError
#@end

--- []=(regexp, nth, val)

正規表現 regexp の nth 番目の括弧にマッチする
最初の部分文字列を文字列 val で置き換えます。

nth が 0 の場合は、マッチした部分文字列全体を val で置き換えます。

@param regexp    置き換えたい部分文字列のパターンを示す正規表現
@param nth       置き換えたい部分文字列のパターンを示す正規表現レジスタの番号
@param val       指定範囲の部分文字列と置き換えたい文字列

@return val を返します。

@raise IndexError 正規表現がマッチしなかった場合に発生します。

#@samplecode 例
buf = "def exec(cmd)"
buf[/def\s+(\w+)/, 1] = "preprocess"
p buf    # => "def preprocess(cmd)"
#@end

--- []=(regexp, name, val)

正規表現 regexp の name で指定した名前付きキャプチャにマッチする最初の
部分文字列を文字列 val で置き換えます。

@param regexp    置き換えたい部分文字列のパターンを示す正規表現
@param name      置き換えたい部分文字列のパターンを示す正規表現レジスタを示す名前
@param val       指定範囲の部分文字列と置き換えたい文字列

@return val を返します。

@raise IndexError name で指定した名前付きキャプチャが存在しない場合に発
                  生します。

#@samplecode 例
s = "FooBar"
s[/(?<foo>[A-Z]..)(?<bar>[A-Z]..)/, "foo"] = "Baz"
p s # => "BazBar"
#@end

--- []=(regexp, val)

正規表現 regexp にマッチした部分文字列全体を val で置き換えます。

@param regexp    置き換えたい部分文字列のパターンを示す正規表現
@param val       置き換えたい文字列

@return val を返します。

@raise IndexError 正規表現がマッチしなかった場合に発生します。

#@samplecode 例
buf = "string"
buf[/tr../] = "!!"
p buf   # => "s!!g"
#@end

--- []=(range, val)

rangeで指定したインデックスの範囲に含まれる部分文字列を文字列 val で置き換えます。

@param range   置き換えたい範囲を示す [[c:Range]] オブジェクト

@return val を返します。

#@since 2.4.0
--- capitalize(*options) -> String

文字列先頭の文字を大文字に、残りを小文字に変更した文字列を返します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- capitalize -> String

文字列先頭の文字を大文字に、残りを小文字に変更した文字列を返します。
ただし、アルファベット以外の文字は位置に関わらず変更しません。
#@end

#@samplecode 例
p "foobar--".capitalize   # => "Foobar--"
p "fooBAR--".capitalize   # => "Foobar--"
p "FOOBAR--".capitalize   # => "Foobar--"
#@end

@see [[m:String#capitalize!]], [[m:String#upcase]],
     [[m:String#downcase]], [[m:String#swapcase]]

#@since 2.4.0
--- capitalize!(*options) -> self | nil

文字列先頭の文字を大文字に、残りを小文字に破壊的に変更します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- capitalize! -> self | nil

文字列先頭の文字を大文字に、残りを小文字に変更します。
ただし、アルファベット以外の文字は位置に関わらず変更しません。
#@end

@return capitalize! は self を変更して返しますが、
        変更が起こらなかった場合は nil を返します。

#@samplecode 例
str = "foobar"
str.capitalize!
p str   # => "Foobar"

str = "fooBAR"
str.capitalize!
p str   # => "Foobar"
#@end

@see [[m:String#capitalize]], [[m:String#upcase!]],
     [[m:String#downcase!]], [[m:String#swapcase!]]

--- casecmp(other) -> -1 | 0 | 1 | nil

[[m:String#<=>]] と同様に文字列の順序を比較しますが、
アルファベットの大文字小文字の違いを無視します。

このメソッドの動作は組み込み変数 [[m:$=]] には影響されません。

#@since 2.4.0
[[m:String#casecmp?]] と違って大文字小文字の違いを無視するのは
Unicode 全体ではなく、A-Z/a-z だけです。
#@end

@param other    self と比較する文字列

#@samplecode 例
"aBcDeF".casecmp("abcde")     #=> 1
"aBcDeF".casecmp("abcdef")    #=> 0
"aBcDeF".casecmp("abcdefg")   #=> -1
"abcdef".casecmp("ABCDEF")    #=> 0
#@end

nil は文字列のエンコーディングが非互換の時に返されます。

#@samplecode
"\u{e4 f6 fc}".encode("ISO-8859-1").casecmp("\u{c4 d6 dc}")   #=> nil
#@end

@see [[m:String#<=>]], [[m:Encoding#compatible?]]

#@since 2.4.0
--- casecmp?(other) -> bool | nil

大文字小文字の違いを無視し文字列を比較します。
文字列が一致する場合には true を返し、一致しない場合には false を返します。

@param other    self と比較する文字列

#@samplecode 例
"abcdef".casecmp?("abcde")     #=> false
"aBcDeF".casecmp?("abcdef")    #=> true
"abcdef".casecmp?("abcdefg")   #=> false
"abcdef".casecmp?("ABCDEF")    #=> true
"\u{e4 f6 fc}".casecmp?("\u{c4 d6 dc}") #=> true
#@end

nil は文字列のエンコーディングが非互換の時に返されます。

#@samplecode
  "\u{e4 f6 fc}".encode("ISO-8859-1").casecmp?("\u{c4 d6 dc}")   #=> nil
#@end

@see [[m:String#casecmp]]
#@end

--- center(width, padding = ' ') -> String

長さ width の文字列に self を中央寄せした文字列を返します。
self の長さが width より長い時には元の文字列の複製を返します。
また、第 2 引数 padding を指定したときは
空白文字の代わりに padding を詰めます。

@param width      返り値の文字列の最小の長さ
@param padding    長さが width になるまで self の両側に詰める文字

#@samplecode 例
p "foo".center(10)       # => "   foo    "
p "foo".center(9)        # => "   foo   "
p "foo".center(8)        # => "  foo   "
p "foo".center(7)        # => "  foo  "
p "foo".center(3)        # => "foo"
p "foo".center(2)        # => "foo"
p "foo".center(1)        # => "foo"
p "foo".center(10, "*")  # => "***foo****"
#@end

@see [[m:String#ljust]], [[m:String#rjust]]

--- ljust(width, padding = ' ') -> String

長さ width の文字列に self を左詰めした文字列を返します。
self の長さが width より長い時には元の文字列の複製を返します。
また、第 2 引数 padding を指定したときは
空白文字の代わりに padding を詰めます。

@param width      返り値の文字列の最小の長さ
@param padding    長さが width になるまで self の右側に詰める文字

#@samplecode 例
p "foo".ljust(10)        # => "foo       "
p "foo".ljust(9)         # => "foo      "
p "foo".ljust(8)         # => "foo     "
p "foo".ljust(2)         # => "foo"
p "foo".ljust(1)         # => "foo"
p "foo".ljust(10, "*")   # => "foo*******"
#@end

@see [[m:String#center]], [[m:String#rjust]]

--- rjust(width, padding = ' ') -> String

長さ width の文字列に self を右詰めした文字列を返します。
self の長さが width より長い時には元の文字列の複製を返します。
また、第 2 引数 padding を指定したときは
空白文字の代わりに padding を詰めます。

@param width      返り値の文字列の最小の長さ
@param padding    長さが width になるまで self の左側に詰める文字

#@samplecode 例
p "foo".rjust(10)        # => "       foo"
p "foo".rjust(9)         # => "      foo"
p "foo".rjust(8)         # => "     foo"
p "foo".rjust(2)         # => "foo"
p "foo".rjust(1)         # => "foo"
p "foo".rjust(10, "*")   # => "*******foo"
#@end

@see [[m:String#center]], [[m:String#ljust]]

--- chomp(rs = $/) -> String

self の末尾から rs で指定する改行コードを取り除いた文字列を生成して返します。
ただし、rs が "\n" ($/ のデフォルト値) のときは、
実行環境によらず "\r", "\r\n", "\n" のすべてを改行コードとみなして取り除きます。

rs に nil を指定した場合、このメソッドは何もしません。

rs に空文字列 ("") を指定した場合は「パラグラフモード」になり、
末尾の連続する改行コードをすべて取り除きます。

#@samplecode 例
p "foo\n".chomp             # => "foo"
p "foo\n".chomp("\n")       # => "foo"
p "foo\r\n".chomp("\r\n")   # => "foo"

$/ = "\n"   # デフォルト値と同じ
p "foo\r".chomp    # => "foo"
p "foo\r\n".chomp  # => "foo"
p "foo\n".chomp    # => "foo"
p "foo\n\r".chomp  # => "foo\n"
#@end

@see [[m:String#chomp!]]
@see [[m:String#chop]]
#@since 2.5.0
@see [[m:String#delete_suffix]]
#@end

--- chomp!(rs = $/) -> self | nil

self の末尾から rs で指定する改行コードを取り除きます。
ただし rs が "\n" ($/ のデフォルト値) のときは、
システムによらず "\r", "\r\n", "\n" のすべてを改行コードとみなして取り除きます。

rs に nil を指定した場合、このメソッドは何もしません。

rs に空文字列 ("") を指定した場合は「パラグラフモード」になり、
末尾の連続する改行コードをすべて取り除きます。

@return chomp! は通常 self を返しますが、取り除く改行がなかった場合は nil を返します。

#@samplecode 例
buf = "string\n"
buf.chomp!
p buf   # => "string"

$/ = "\n"   # デフォルトと同じ
p "foo\r".chomp!    # => "foo"
p "foo\r\n".chomp!  # => "foo"
p "foo\n".chomp!    # => "foo"
p "foo\n\r".chomp!  # => "foo\n"
#@end

@see [[m:String#chomp]]
@see [[m:String#chop!]]
#@since 2.5.0
@see [[m:String#delete_suffix!]]
#@end

--- chop -> String

文字列の最後の文字を取り除いた新しい文字列を生成して返します。
ただし、文字列の終端が "\r\n" であればその 2 文字を取り除きます。

#@samplecode 例
p "string\n".chop    # => "string"
p "string\r\n".chop  # => "string"
p "string".chop      # => "strin"
p "strin".chop       # => "stri"
p "".chop            # => ""
#@end

@see [[m:String#chomp]]
@see [[m:String#chop!]]
#@since 2.5.0
@see [[m:String#delete_suffix]]
#@end

--- chop! -> self | nil

文字列の最後の文字を取り除きます。
ただし、終端が "\r\n" であればその 2 文字を取り除きます。

@return chop! は self を変更して返しますが、取り除く文字がなかった場合は nil を返します。

#@samplecode 例
  str = "string\r\n"
  ret = str.chop!
  ret                  # => "string"
  str                  # => "string"
  str.chop!            # => "strin"
  "".chop!             # => nil
#@end

@see [[m:String#chomp!]]
@see [[m:String#chop]]
#@since 2.5.0
@see [[m:String#delete_suffix!]]
#@end

--- clear -> self

文字列の内容を削除して空にします。
self を返します。

#@samplecode 例
    str = "abc"
    str.clear
    p str     # => ""

    str = ""
    str.clear
    p str   # => ""
#@end

#@#--- clone
#@#--- dup
#@#
#@#文字列と同じ内容を持つ新しい文字列を返します。
#@#フリーズ [[m:Object#freeze]] した文字列の
#@#clone はフリーズされた文字列を返しますが、
#@#dup は内容の等しいフリーズされていない文字列を返します。
#@#すなわち dup と [[m:String#new]] は等価です。
#@#
#@# [[m:Object#clone]],[[m:Object#dup]]を参照するべき

--- count(*chars) -> Integer

chars で指定された文字が文字列 self にいくつあるか数えます。

検索する文字を示す引数 chars の形式は [[man:tr(1)]] と同じです。
つまり、「"a-c"」は文字 a から c を意味し、
「"^0-9"」のように文字列の先頭が「^」の場合は
指定文字以外を意味します。

文字「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、「^」も文字列の先頭にあるときだけ否定の効果を発揮します。
また、「-」「^」「\」は
バックスラッシュ (「\」) によりエスケープできます。

引数を複数指定した場合は、
すべての引数にマッチした文字だけを数えます。

@param chars    出現回数を数える文字のパターン

#@samplecode 例
p 'abcdefg'.count('c')               # => 1
p '123456789'.count('2378')          # => 4
p '123456789'.count('2-8', '^4-6')   # => 4

# ファイルの行数を数える
n_lines = File.open("foo").read.count("\n")

# ファイルの末尾に改行コードがない場合にも対処する
buf = File.open("foo").read
n_lines = buf.count("\n")
n_lines += 1 if /[^\n]\z/ =~ buf
           # if /\n\z/ !~ buf だと空ファイルを 1 行として数えてしまうのでダメ
#@end

--- crypt(salt) -> String

self と salt から暗号化された文字列を生成して返します。
salt には英数字、ドット (「.」)、スラッシュ (「/」) から構成される、
2 バイト以上の文字列を指定します。

暗号化された文字列から暗号化前の文字列 (self) を求めることは一般に困難で、
self を知っている者のみが同じ暗号化された文字列を生成できます。
このことから self を知っているかどうかの認証に使うことが出来ます。

salt には、以下の様になるべくランダムな文字列を選ぶべきです。
他にも [[ruby-list:29297]] などがあります。

注意:

  * Ruby 2.6 から非推奨になったため、引き続き必要な場合は
    string-crypt gem の使用を検討してください。
  * crypt の処理は [[man:crypt(3)]] の実装に依存しています。
    従って、crypt で処理される内容の詳細や salt の与え方については、
    利用環境の [[man:crypt(3)]] 等を見て確認してください。
  * crypt の結果は利用環境が異なると変わる場合があります。
    crypt の結果を、異なる利用環境間で使用する場合には注意して下さい。
  * 典型的な DES を使用した [[man:crypt(3)]] の場合、
    self の最初の 8 バイト、salt の最初の 2 バイトだけが使用されます。

@param salt    文字列を暗号化するための鍵となる文字列。
             英数字・「.」・「/」のいずれかで構成される 2 バイト以上の文字列

#@samplecode 例
# パスワードの暗号化
salt = [rand(64),rand(64)].pack("C*").tr("\x00-\x3f","A-Za-z0-9./")
passwd.crypt(salt)

# UNIX のログイン認証
require 'etc'

def valid_login?(user, password)
  ent = Etc.getpwnam(user)
  password.crypt(ent.passwd) == ent.passwd
end

p valid_login?("taro", "password")   # => 真偽値が得られる
#@end

--- delete(*strs) -> String

self から strs に含まれる文字を取り除いた文字列を生成して返します。

str の形式は [[man:tr(1)]] と同じです。
つまり、`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外を意味します。

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
「^」も文字列の先頭にあるときだけ効果を発揮します。
また、「-」「^」「\」はバックスラッシュ (「\」)
によってエスケープできます。

なお、引数を複数指定した場合は、
すべての引数にマッチする文字だけが削除されます。

@param strs    削除する文字列を示す文字列 (のリスト)

#@samplecode 例
p "123456789".delete("2378")         #=> "14569"
p "123456789".delete("2-8", "^4-6")  #=> "14569"
#@end

@see [[m:String#delete!]]

--- delete!(*strs) -> self | nil

self から strs に含まれる文字を破壊的に取り除きます。

str の形式は [[man:tr(1)]] と同じです。
つまり、「a-c」は a から c を意味し、"^0-9" のように
文字列の先頭が「^」の場合は指定文字以外を意味します。

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
「^」も文字列先頭にあるときだけ否定の効果を発揮します。
また、「-」「^」「\」はバックスラッシュ (「\」)
によってエスケープできます。

なお、引数を複数指定した場合は、
すべての引数にマッチする文字だけが削除されます。

@return 通常は self を返しますが、何も変更が起こらなかった場合は nil を返します。

@param strs    削除する文字列を示す文字列 (のリスト)

#@samplecode 例
str = "123456789"
p str.delete!("2378")         #=> "14569"
p str                         #=> "14569"

str = "123456789"
p str.delete!("2-8", "^4-6")  #=> "14569"
p str                         #=> "14569"

str = "abc"
p str.delete!("2378")         #=> "nil"
p str                         #=> "abc"
#@end

@see [[m:String#delete]]

#@since 2.4.0
--- downcase(*options) -> String

全ての大文字を対応する小文字に置き換えた文字列を返します。
どの文字がどう置き換えられるかは、オプションの有無や文字列のエンコーディングに依存します。

@param options オプションの意味は以下の通りです。

: オプションなし
  完全な Unicode ケースマッピングに対応し、ほとんどの言語に適しています。(例外は以下の :turkic,
  :lithuanian オプションを参照)
  Unicode 標準の表 3-14 で説明されている、コンテキスト依存のケースマッピングは、現在サポートされていません。

: :ascii
  ASCII の範囲内のみ (A-Z, a-z) が影響します。
  このオプションは他のオプションと組み合わせることはできません。

: :turkic
  チュルク語族 (トルコ語、アゼルバイジャン語など) に適合した完全な Unicode ケースマッピングです。
  これはたとえば大文字の I は小文字のドットなしの i (ı) にマッピングされることを意味します。

: :lithuanian
  現在は、ただの完全な Unicode ケースマッピングです。
  将来、リトアニア語に対応した完全な Unicode ケースマッピングです。
  (上にアクセントがあっても小文字の i のドットを維持します。)

: :fold
  downcase と downcase! のみで使えます。
  Unicode ケースフォールディングは Unicode ケースマッピングより広範囲です。
  このオプションは今の所、他のオプションと組み合わせることはできません。
  (すなわち現在チュルク語族のバリアントはありません。)

ASCII のみの大文字小文字変換で有効ないくつかの仮定は、より一般的なケース変換では
成り立たないことに注意してください。例えば、結果の長さは入力の長さと同じとは
限りません (文字数でもバイト数でも)。ラウンドトリップできるという仮定も
成り立ちません (例えば str.downcase == str.upcase.downcase)。
そして、Unicode 正規化 (すなわち [[m:String#unicode_normalize]]) はケース
マッピング操作で必ずしも維持されるとは限りません。

現在 ASCII 以外のケースマッピング/フォールディングは、UTF-8, UTF-16BE/LE,
UTF-32BE/LE, ISO-8859-1~16 の String/Symbol でサポートされています。
他のエンコーディングもサポートされる予定です。

#@else
--- downcase -> String

'A' から 'Z' までの
アルファベット大文字をすべて小文字に置き換えた新しい文字列を生成して返します。
アルファベット大文字以外の文字はすべてそのまま保存されます。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。
#@end

#@samplecode 例
p "STRing?".downcase   # => "string?"
#@end
@see [[m:String#downcase!]], [[m:String#upcase]], [[m:String#swapcase]], [[m:String#capitalize]]

#@since 2.4.0
--- downcase!(*options) -> self | nil

全ての大文字を対応する小文字に破壊的に置き換えます。
どの文字がどう置き換えられるかは、オプションの有無や文字列のエンコーディングに依存します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- downcase! -> self | nil

文字列中の 'A' から 'Z' までの
アルファベット大文字をすべて破壊的に小文字に置き換えます。
アルファベット大文字以外の文字はすべてそのまま保存されます。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。
#@end
@return self を変更して返します。変更が無かった場合は nil を返します。

#@samplecode 例
str = "STRing?"
str.downcase!
p str   # => "string?"
#@end

@see [[m:String#downcase]], [[m:String#upcase!]], [[m:String#swapcase!]], [[m:String#capitalize!]]

--- dump -> String

文字列中の非表示文字をバックスラッシュ記法に置き換えた文字列を返します。
str == eval(str.dump) となることが保証されています。

#@samplecode 例
# p だとさらにバックスラッシュが増えて見にくいので puts している
puts "abc\r\n\f\x00\b10\\\"".dump   # => "abc\r\n\f\000\01010\\\""
#@end

#@since 2.5.0
@see [[m:String#undump]]
--- undump -> String
self のエスケープを戻したものを返します。

[[m:String#dump]] の逆変換にあたります。

#@samplecode 例
"\"hello \\n ''\"".undump #=> "hello \n ''"
#@end

@see [[m:String#dump]]
#@end
#@since 2.4.0
--- each_line(rs = $/, chomp: false) {|line| ... } -> self
--- each_line(rs = $/, chomp: false)  -> Enumerator
#@else
--- each_line(rs = $/) {|line| ... } -> self
--- each_line(rs = $/)  -> Enumerator
#@end

文字列中の各行に対して繰り返します。
行の区切りは rs に指定した文字列で、
そのデフォルト値は変数 [[m:$/]] の値です。
各 line には区切りの文字列も含みます。

rs に nil を指定すると行区切りなしとみなします。
rs に空文字列 "" を指定すると「パラグラフモード」になり、
改行コードが 2 つ以上連続するところで文字列を分割します
(つまり空行で分割します)。

@param rs    行末を示す文字列
#@since 2.4.0
@param chomp true を指定すると各行の末尾から "\n", "\r", または "\r\n" を取り除きます。
#@end

#@samplecode 例
"aa\nbb\ncc\n".each_line do |line|
  p line
end
    # => "aa\n"
    # => "bb\n"
    # => "cc\n"

p "aa\nbb\ncc\n".lines.to_a   # => ["aa\n", "bb\n", "cc\n"]
p "aa\n".lines.to_a           # => ["aa\n"]
p "".lines.to_a               # => []

s = "aa\nbb\ncc\n"
p s.lines("\n").to_a #=> ["aa\n", "bb\n", "cc\n"]  
p s.lines("bb").to_a #=> ["aa\nbb", "\ncc\n"]  
#@end

@see [[m:String#lines]]

#@since 2.4.0
--- lines(rs = $/, chomp: false)               -> [String]
--- lines(rs = $/, chomp: false) {|line| ... } -> self
#@else
--- lines(rs = $/)               -> [String]
--- lines(rs = $/) {|line| ... } -> self
#@end

文字列中の各行を文字列の配列で返します。(self.each_line.to_a と同じです)

#@samplecode
  "aa\nbb\ncc\n".lines # => ["aa\n", "bb\n", "cc\n"]
#@end

行の区切りは rs に指定した文字列で、 そのデフォルト値は変数 $/ の値です。
各 line には区切りの文字列も含みます。

rs に nil を指定すると行区切りなしとみなします。 rs に空文字列 "" を指
定すると「パラグラフモード」になり、 改行コードが 2 つ以上連続するとこ
ろで文字列を分割します (つまり空行で分割します)。

#@since 2.4.0
chomp に true を指定すると、分割した各行に対して [[m:String#chomp]]
を実行するのと同等の結果を得ることができます。

#@samplecode
  "hello\nworld\n".lines              # => ["hello\n", "world\n"]
  "hello\nworld\n".lines(chomp: true) # => ["hello", "world"]
#@end
#@end
  
@param rs 行末を示す文字列

#@since 2.4.0
@param chomp 分割した各行に対して [[m:String#chomp]] と同等の結果を得
             る場合は true を、そうでない場合は false で指定します。
             省略した場合は false を指定したとみなされます。
#@end

ブロックが指定された場合は [[m:String#each_line]] と同じように動作しま
す。ただし obsolete のため、ブロックを指定する場合は
[[m:String#each_line]] を使用してください。

@see [[m:String#each_line]]

--- each_byte {|byte| ... } -> self
--- each_byte -> Enumerator

文字列の各バイトに対して繰り返します。

#@samplecode 例
"str".each_byte do |byte|
  p byte
end
    # => 115
    # => 116
    # => 114
#@end

@see [[m:String#bytes]]

--- bytes               -> [Integer]
--- bytes {|byte| ... } -> self

文字列の各バイトを数値の配列で返します。(self.each_byte.to_a と同じです)

#@samplecode 例
"str".bytes # => [115, 116, 114]
#@end

ブロックが指定された場合は [[m:String#each_byte]] と同じように動作しま
す。ただし obsolete のため、ブロックを指定する場合は
[[m:String#each_byte]] を使用してください。

@see [[m:String#each_byte]]

--- empty? -> bool

文字列が空 (つまり長さ 0) の時、真を返します。

#@samplecode 例
"hello".empty?   #=> false
" ".empty?       #=> false
"".empty?        #=> true
#@end

--- getbyte(index) -> Integer | nil

index バイト目のバイトを整数で返します。

index に負を指定すると末尾から数えた位置のバイト
を取り出します。
範囲外を指定した場合は nil を返します。

@param index バイトを取り出す位置

#@samplecode 例
s = "tester"
s.bytes             # => [116, 101, 115, 116, 101, 114]
s.getbyte(0)        # => 116
s.getbyte(1)        # => 101
s.getbyte(-1)       # => 114
s.getbyte(6)        # => nil
#@end

--- setbyte(index, b) -> Integer

index バイト目のバイトを b に変更します。 

index に負を指定すると末尾から数えた位置を変更します。

セットした値を返します。

@param index バイトをセットする位置
@param b セットするバイト(0 から 255 までの整数)
@raise IndexError 範囲外に値をセットしようとした場合に発生します。

#@samplecode 例
s = "Sunday"
s.setbyte(0, 77)
s.setbyte(-5, 111)
s # => "Monday"
#@end

--- gsub(pattern, replace) -> String

文字列中で pattern にマッチする部分全てを
文字列 replace で置き換えた文字列を生成して返します。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@param replace    pattern で指定した文字列と置き換える文字列

#@samplecode 例
p 'abcdefg'.gsub(/def/, '!!')          # => "abc!!g"
p 'abcabc'.gsub(/b/, '<<\&>>')         # => "a<<b>>ca<<b>>c"
p 'xxbbxbb'.gsub(/x+(b+)/, 'X<<\1>>')  # => "X<<bb>>X<<bb>>"
p '2.5'.gsub('.', ',') # => "2,5"
#@end

注意:

第 2 引数 replace に [[m:$1]] を埋め込んでも意図した結果にはなりません。
この文字列が評価される時点ではまだ正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、gsub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

#@samplecode ひとつめの括弧の内容に置き換えるときによくある間違い
p 'xbbb-xbbb'.gsub(/x(b+)/, "#{$1}")   # => "-"        # NG
p 'xbbb-xbbb'.gsub(/x(b+)/, "\1")      # => "1-1"      # NG
p 'xbbb-xbbb'.gsub(/x(b+)/, "\\1")     # => "bbb-bbb"  # OK
p 'xbbb-xbbb'.gsub(/x(b+)/, '\1')      # => "bbb-bbb"  # OK
p 'xbbb-xbbb'.gsub(/x(b+)/, '\\1')     # => "bbb-bbb"  # OK
#@end

#@samplecode バックスラッシュを倍にするときによくある間違い
puts '\n'.gsub(/\\/, "\\\\")      # => \n   # NG
puts '\n'.gsub(/\\/, '\\\\')      # => \n   # NG
puts '\n'.gsub(/\\/, "\\\\\\\\")  # => \\n  # OK
puts '\n'.gsub(/\\/, '\\\\\\\\')  # => \\n  # OK
#@end

このような間違いを確実に防止し、コードの可読性を上げるには、
\& や \1 よりも下記のようにブロック付き形式の gsub を使うべきです。

#@samplecode
p 'xbbb-xbbb'.gsub(/x(b+)/) { $1 }   # => "bbb-bbb"  # OK

puts '\n'.gsub(/\\/) { '\\\\' }      # => \\n        # OK
#@end

@see [[m:String#sub]]

--- gsub(pattern) {|matched| .... } -> String
--- gsub(pattern) -> Enumerator

文字列中で pattern にマッチした部分を順番にブロックに渡し、
その実行結果で置き換えた文字列を生成して返します。
ブロックなしの場合と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@return 新しい文字列

#@samplecode 例
p 'abcabc'.gsub(/[bc]/) {|s| s.upcase }  #=> "aBCaBC"
p 'abcabc'.gsub(/[bc]/) { $&.upcase }    #=> "aBCaBC"
#@end

@see [[m:String#sub]], [[m:String#scan]]

--- gsub(pattern, hash) -> String

文字列中の pattern にマッチした部分をキーにして hash を引いた値で置き換えます。

@param pattern    置き換える文字列のパターン
@param hash       置き換える文字列を与えるハッシュ

#@samplecode 例
hash = {'b'=>'B', 'c'=>'C'}
p "abcabc".gsub(/[bc]/){hash[$&]} #=> "aBCaBC"
p "abcabc".gsub(/[bc]/, hash)     #=> "aBCaBC"
#@end

--- gsub!(pattern, replace) -> self | nil

文字列中で pattern にマッチする部分全てを文字列 replace に破壊的に置き換えます。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

gsub! は通常 self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@param replace    pattern で指定した文字列と置き換える文字列
@return 置換した場合は self、置換しなかった場合は nil

#@samplecode 例
buf = "String-String"
buf.gsub!(/in./, "!!")
p buf   # => "Str!!-Str!!"

buf = "String.String"
buf.gsub!(/in./, '<<\&>>')
p buf   # => "Str<<ing>>-Str<<ing>>"
#@end

注意:

引数 replace の中で [[m:$1]] を使うことはできません。
replace は gsub メソッドの呼び出しより先に評価されるので、
まだ gsub の正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、gsub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

#@samplecode ひとつめの括弧にマッチした部分に置き換えるときによくやる間違い
'abbbcd'.gsub!(/a(b+)/, "#{$1}")       # NG
'abbbcd'.gsub!(/a(b+)/, "\1")          # NG
'abbbcd'.gsub!(/a(b+)/, "\\1")         # OK
'abbbcd'.gsub!(/a(b+)/, '\\1')         # OK
'abbbcd'.gsub!(/a(b+)/, '\1')          # OK
'abbbcd'.gsub!(/a(b+)/) { $1 }         # OK   これがもっとも安全
#@end

@see [[m:String#sub]]

--- gsub!(pattern) {|matched| .... } -> self | nil
--- gsub!(pattern) -> Enumerator

文字列中で pattern にマッチする部分全てを順番にブロックに渡し、
その評価結果に置き換えます。

また、ブロックなしの場合と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@return 置換した場合は self、置換しなかった場合は nil

#@samplecode 例
str = 'abcabc'
str.gsub!(/b/) {|s| s.upcase }
p str    #=> "aBcaBc"

str = 'abcabc'
str.gsub!(/b/) { $&.upcase }
p str    #=> "aBcaBc"
#@end

@see [[m:String#sub]]

--- gsub!(pattern, hash) -> self | nil

文字列中の pattern にマッチした部分をキーにして hash を引いた値へ破壊的に置き換えます。

@param pattern    置き換える文字列のパターン
@param hash       置き換える文字列を与えるハッシュ

#@samplecode 例
hash = {'b'=>'B', 'c'=>'C'}
str = "abcabc"
str.gsub!(/[bc]/){hash[$&]}
p str     #=> "aBCaBC"

str = "abcabc"
str.gsub!(/[bc]/, hash)
p str     #=> "aBCaBC"
#@end

--- hex -> Integer

文字列に 16 進数で数値が表現されていると解釈して整数に変換します。
接頭辞 "0x", "0X" とアンダースコアは無視されます。
文字列が [_0-9a-fA-F] 以外の文字を含むときはその文字以降を無視します。

self が空文字列のときは 0 を返します。

#@samplecode 例
p "10".hex    # => 16
p "ff".hex    # => 255
p "0x10".hex  # => 16
p "-0x10".hex # => -16

p "xyz".hex   # => 0
p "10z".hex   # => 16
p "1_0".hex   # => 16

p "".hex      # => 0
#@end

@see [[m:String#oct]], [[m:String#to_i]], [[m:String#to_f]],
     [[m:Kernel.#Integer]], [[m:Kernel.#Float]]

このメソッドの逆に数値を文字列に変換するには
[[m:Kernel.#sprintf]], [[m:String#%]],
[[m:Integer#to_s]]
などを使ってください。

--- include?(substr) -> bool

文字列中に部分文字列 substr が含まれていれば真を返します。

@param substr    検索する文字列

#@samplecode 例
"hello".include? "lo"   #=> true
"hello".include? "ol"   #=> false
"hello".include? ?h     #=> true
#@end

--- index(pattern, pos = 0) -> Integer

文字列のインデックス pos から右に向かって pattern を検索し、
最初に見つかった部分文字列の左端のインデックスを返します。
見つからなければ nil を返します。

引数 pattern は探索する部分文字列または正規表現で指定します。

pos が負の場合、文字列の末尾から数えた位置から探索します。

@param pattern    探索する部分文字列または正規表現
@param pos        探索を開始するインデックス

#@samplecode 例
p "astrochemistry".index("str")         # => 1
p "regexpindex".index(/e.*x/, 2)        # => 3
p "character".index(?c)                 # => 0

p "foobarfoobar".index("bar", 6)        # => 9
p "foobarfoobar".index("bar", -6)       # => 9
#@end

@see [[m:String#rindex]]

--- insert(pos, other) -> self

pos 番目の文字の直前に文字列 other を挿入します。
self[pos, 0] = other と同じ操作です。

@param pos      文字列を挿入するインデックス
@param other    挿入する文字列

#@samplecode 例
str = "foobaz"
str.insert(3, "bar")
p str   # => "foobarbaz"
#@end

@see [[m:String#[]=]]

--- intern -> Symbol
--- to_sym -> Symbol

文字列に対応するシンボル値 [[c:Symbol]] を返します。

なお、このメソッドの逆にシンボルに対応する文字列を得るには
[[m:Symbol#to_s]] または [[m:Symbol#id2name]] を使います。

シンボル文字列にはナルキャラクタ("\0")、空の文字列の使用も可能です。

#@samplecode 例
p "foo".intern                 # => :foo
p "foo".intern.to_s == "foo"   # => true
#@end

--- length -> Integer
--- size -> Integer

文字列の文字数を返します。バイト数を知りたいときは bytesize メソッドを使ってください。

#@samplecode 例
"test".length   # => 4
"test".size     # => 4
"テスト".length   # => 3
"テスト".size     # => 3
#@end

@see [[m:String#bytesize]]

--- match(regexp, pos = 0) -> MatchData | nil
--- match(regexp, pos = 0) {|m| ... } -> object

regexp.match(self, pos) と同じです。
regexp が文字列の場合は、正規表現にコンパイルします。
詳しくは [[m:Regexp#match]] を参照してください。

#@samplecode 例: regexp のみの場合
'hello'.match('(.)\1')      # => #<MatchData "ll" 1:"l">
'hello'.match('(.)\1')[0]   # => "ll"
'hello'.match(/(.)\1/)[0]   # => "ll"
'hello'.match('xx')         # => nil
#@end

#@samplecode 例: regexp, pos を指定した場合
'hoge hige hege bar'.match('h.ge', 0)     # => #<MatchData "hoge">
'hoge hige hege bar'.match('h.ge', 1)     # => #<MatchData "hige">
#@end

#@samplecode 例: ブロックを指定した場合
'hello'.match('(.)\1'){|e|"match #{$1}"}  # => "match l"
'hello'.match('xx'){|e|"match #{$1}"}     # マッチしないためブロックは実行されない
#@end

@see [[m:Regexp#match]], [[m:Symbol#match]]

#@since 2.4.0
--- match?(regexp, pos = 0) -> bool

regexp.match?(self, pos) と同じです。
regexp が文字列の場合は、正規表現にコンパイルします。
詳しくは [[m:Regexp#match?]] を参照してください。

#@samplecode 例
"Ruby".match?(/R.../)    #=> true
"Ruby".match?(/R.../, 1) #=> false
"Ruby".match?(/P.../)    #=> false
$&                       #=> nil
#@end

@see [[m:Regexp#match?]], [[m:Symbol#match?]]
#@end

--- succ -> String
--- next -> String

self の「次の」文字列を返します。

「次の」文字列は、対象の文字列の右端から
アルファベットなら アルファベット順(aの次はb, zの次はa, 大文字も同様)に、 
数字なら 10 進数(9 の次は 0)とみなして計算されます。

#@samplecode
p "aa".succ        # => "ab"
p "88".succ.succ   # => "90"
#@end

"99" → "100", "AZZ" → "BAA" のような繰り上げも行われます。
このとき負符号などは考慮されません。

#@samplecode
p "99".succ   # => "100"
p "ZZ".succ   # => "AAA"
p "a9".succ   # => "b0"
p "-9".succ   # => "-10"
#@end

self にアルファベットや数字とそれ以外の文字が混在している場合、
アルファベットと数字だけが「次の」文字になり、残りは保存されます。

#@samplecode
p "1.9.9".succ # => # "2.0.0"
#@end

逆に self がアルファベットや数字をまったく含まない場合は、
単純に文字コードを 1 増やします。

#@samplecode
p ".".succ     # => "/"
#@end

さらに、self が空文字列の場合は "" を返します。
このメソッドはマルチバイト文字を意識せず、
単に文字列をバイト列として扱います。

なお、succ と逆の動作をするメソッドはありません。
また、succ という名前の由来は successor です。


#@samplecode 例
p "aa".succ   # => "ab"

# 繰り上がり
p "99".succ   # => "100"
p "a9".succ   # => "b0"
p "Az".succ   # => "Ba"
p "zz".succ   # => "aaa"
p "-9".succ   # => "-10"
p "9".succ    # => "10"
p "09".succ   # => "10"

# アルファベット・数字とそれ以外の混在
p "1.9.9".succ # => # "2.0.0"

# アルファベット・数字以外のみ
p ".".succ     # => "/"
p "\0".succ    # => "\001"
p "\377".succ  # => "\001\000"
#@end

このメソッドは文字列の [[c:Range]] の内部で使用されます。

--- succ! -> String
--- next! -> String

self を「次の」文字列に置き換えます。
「次の」文字列は、アルファベットなら 16 進数、
数字なら 10 進数とみなして計算されます。
「次の」文字列の計算では "99" → "100" のように繰り上げも行われます。
このとき負符号などは考慮されません。

self にアルファベットや数字とそれ以外の文字が混在している場合、
アルファベットと数字だけが「次の」文字になり、残りは保存されます。
逆に self がアルファベットや数字をまったく含まない場合は、
単純に文字コードを 1 増やします。

さらに、self が空文字列の場合は "" を返します。

このメソッドはマルチバイト文字を意識せず、
単に文字列をバイト列として扱います。

なお、succ! と逆の動作をするメソッドはありません。

#@samplecode 例
p "aa".succ   # => "ab"

# 繰り上がり
p "99".succ   # => "100"
p "a9".succ   # => "b0"
p "Az".succ   # => "Ba"
p "zz".succ   # => "aaa"
p "-9".succ   # => "-10"
p "9".succ    # => "10"
p "09".succ   # => "10"

# アルファベット・数字とそれ以外の混在
p "1.9.9".succ # => # "2.0.0"

# アルファベット・数字以外のみ
p ".".succ     # => "/"
p "\0".succ    # => "\001"
p "\377".succ  # => "\001\000"
#@end

@see [[m:String#succ]]

--- oct -> Integer

文字列を 8 進文字列であると解釈して、整数に変換します。

#@samplecode 例
p "10".oct  # => 8
p "010".oct # => 8
p "8".oct   # => 0
#@end

oct は文字列の接頭辞 ("0", "0b", "0B", "0x", "0X") に応じて
8 進以外の変換も行います。

#@samplecode 例
p "0b10".oct  # => 2
p "10".oct    # => 8
p "010".oct   # => 8
p "0x10".oct  # => 16
#@end

整数とみなせない文字があればそこまでを変換対象とします。
変換対象が空文字列であれば 0 を返します。

符号や _ が含まれる場合も変換対象になります。

#@samplecode 例
p "-010".oct     # => -8
p "-0x10".oct    # => 0
p "-0b10".oct    # => 0

p "1_0_1x".oct   # => 65
#@end

@see [[m:String#hex]], [[m:String#to_i]], [[m:String#to_f]],
     [[m:Kernel.#Integer]], [[m:Kernel.#Float]]

逆に、数値を文字列に変換するには[[m:Kernel.#sprintf]],
[[m:String#%]], [[m:Integer#to_s]] を使用します。

--- replace(other) -> String

self の内容を other の内容で置き換えます。

#@samplecode 例
str = "foo"
str.replace "bar"
p str   # => "bar"
#@end

--- reverse -> String

文字列を文字単位で左右逆転した文字列を返します。

#@samplecode 例
p "foobar".reverse   # => "raboof"
p "".reverse         # => ""
#@end

--- reverse! -> self

文字列を文字単位で左右逆転します。

#@samplecode 例
str = "foobar"
str.reverse!
p str   # => "raboof"
#@end

--- rindex(pattern, pos = self.size) -> Integer | nil

文字列のインデックス pos から左に向かって pattern を探索します。
最初に見つかった部分文字列の左端のインデックスを返します。
見つからなければ nil を返します。

引数 pattern は探索する部分文字列または正規表現で指定します。

pos が負の場合は、文字列の末尾から数えた位置から探索します。

rindex と [[m:String#index]] とでは、探索方向だけが逆になります。
完全に左右が反転した動作をするわけではありません。
探索はその開始位置を右から左にずらしながら行いますが、
部分文字列の照合はどちらのメソッドも左から右に向かって行います。
以下の例を参照してください。

#@samplecode String#index の場合
p "stringstring".index("ing", 1)    # => 3
  # ing            # ここから探索を始める
  #  ing
  #   ing          # 右にずらしていってここで見つかる
#@end

#@samplecode String#rindex の場合
p "stringstring".rindex("ing", -1)  # => 9
  #           ing    # インデックス -1 の文字から探索を始める
  #          ing
  #         ing      # 左にずらしていってここで見つかる
#@end

@param pattern    探索する部分文字列または正規表現
@param pos       探索を始めるインデックス

#@samplecode 例
p "astrochemistry".rindex("str")        # => 10
p "character".rindex(?c)                # => 5
p "regexprindex".rindex(/e.*x/, 2)      # => 1

p "foobarfoobar".rindex("bar", 6)       # => 3
p "foobarfoobar".rindex("bar", -6)      # => 3
#@end

@see [[m:String#index]]

--- scan(pattern) -> [String] | [[String]]

self に対して pattern を繰り返しマッチし、
マッチした部分文字列の配列を返します。

pattern が正規表現で括弧を含む場合は、
括弧で括られたパターンにマッチした部分文字列の配列の配列を返します。

@param pattern 探索する部分文字列または正規表現

#@samplecode 例
p "foobar".scan(/../)               # => ["fo", "ob", "ar"]
p "foobar".scan("o")                # => ["o", "o"]
p "foobarbazfoobarbaz".scan(/ba./)  # => ["bar", "baz", "bar", "baz"]

p "foobar".scan(/(.)/) # => [["f"], ["o"], ["o"], ["b"], ["a"], ["r"]]

p "foobarbazfoobarbaz".scan(/(ba)(.)/) # => [["ba", "r"], ["ba", "z"], ["ba", "r"], ["ba", "z"]]
#@end

--- scan(pattern) {|s| ... } -> self

pattern がマッチした部分文字列をブロックに渡して実行します。
pattern が正規表現で括弧を含む場合は、
括弧で括られたパターンにマッチした文字列の配列を渡します。

@param pattern 探索する部分文字列または正規表現

#@samplecode 例
"foobarbazfoobarbaz".scan(/ba./) {|s| p s }
    # => "bar"
    #    "baz"
    #    "baz"
    #    "baz"

"foobarbazfoobarbaz".scan("ba") {|s| p s }
    # => "ba"
    #    "ba"
    #    "ba"
    #    "ba"

"foobarbazfoobarbaz".scan(/(ba)(.)/) {|s| p s }
    # => ["ba", "r"]
    #    ["ba", "z"]
    #    ["ba", "r"]
    #    ["ba", "z"]
#@end

--- slice!(nth) -> Integer
--- slice!(pos, len) -> String
--- slice!(substr) -> String
--- slice!(regexp, nth = 0) -> String
--- slice!(first..last) -> String
--- slice!(first...last) -> String
--- slice!(regexp, nth = 0) -> String

指定した範囲 ([[m:String#[] ]] 参照) を
文字列から取り除いたうえで取り除いた部分文字列を返します。

引数が範囲外を指す場合は nil を返します。

#@samplecode 例
string = "this is a string"
string.slice!(2)        #=> "i"
string.slice!(3..6)     #=> " is "
string.slice!(/s.*t/)   #=> "sa st"
string.slice!("r")      #=> "r"
string                  #=> "thing"
#@end

--- split(sep = $;, limit = 0) -> [String]
#@since 2.6.0
--- split(sep = $;, limit = 0) {|s| ... } -> self
#@end

第 1 引数 sep で指定されたセパレータによって文字列を limit 個まで分割し、
結果を文字列の配列で返します。
#@since 2.6.0
ブロックを指定すると、配列を返す代わりに分割した文字列で
ブロックを呼び出します。
#@end

第 1 引数 sep は以下のいずれかです。

: 正規表現
    正規表現にマッチする部分で分割する。
    特に、括弧によるグルーピングがあればそのグループにマッチした
    文字列も結果の配列に含まれる (後述)。
: 文字列
    その文字列自体にマッチする部分で分割する。
: 1 バイトの空白文字 ' '
    先頭と末尾の空白を除いたうえで、空白文字列で分割する。
: nil
    常に $; で分割する。 $; も nil の場合は、先頭と末尾の空白を除いたうえで、空白文字列で分割する。
: 空文字列 '' あるいは空文字列にマッチする正規表現
    文字列を 1 文字ずつに分割する。マルチバイト文字を認識する。

sep が正規表現で、かつその正規表現に括弧が含まれている場合には、
各括弧のパターンにマッチした文字列も配列に含まれます。
括弧が複数ある場合は、マッチしたものだけが配列に含まれます。

第 2 引数 limit は以下のいずれかです。

: limit > 0
     最大 limit 個の文字列に分割する
: limit == 0
     分割個数制限はなしで、配列末尾の空文字列を取り除く
: limit < 0
     分割個数の制限はなし

@param sep       文字列を分割するときのセパレータのパターン
@param limit     分割する最大個数

#@since 2.6.0
@return ブロックを渡した場合は self、ブロックなしの場合は配列
#@end

#@samplecode 例
p "   a \t  b \n  c".split(/\s+/) # => ["", "a", "b", "c"]

p "   a \t  b \n  c".split(nil)   # => ["a", "b", "c"]
p "   a \t  b \n  c".split(' ')   # => ["a", "b", "c"]   # split(nil) と同じ
p "   a \t  b \n  c".split        # => ["a", "b", "c"]   # split(nil) と同じ
#@end

#@samplecode 括弧を含む正規表現
p '1-10,20'.split(/([-,])/)   # => ["1", "-", "10", ",", "20"]
#@end

#@samplecode 正規表現が空文字列にマッチする場合は 1 文字に分割
p 'hi there'.split(/\s*/).join(':')  # => "h:i:t:h:e:r:e"
#@end

#@samplecode 文字列全体を 1 文字ずつに分割する例
p 'hi there'.split(//).join(':')     # => "h:i: :t:h:e:r:e"
#@end

#@samplecode limit == 0 だと制限なく分割、配列末尾の空文字列は取り除かれる
p "a,b,c,,,".split(/,/, 0)   # => ["a", "b", "c"]
#@end

#@samplecode limit 省略時は 0 と同じ (最もよく使われるパターン)
p "a,b,c,,,".split(/,/)      # => ["a", "b", "c"]
#@end

#@samplecode 正の limit 使用例
p "a,b,c,d,e".split(/,/, 1)  # => ["a,b,c,d,e"]
p "a,b,c,d,e".split(/,/, 2)  # => ["a", "b,c,d,e"]
p "a,b,c,d,e".split(/,/, 3)  # => ["a", "b", "c,d,e"]
p "a,b,c,d,e".split(/,/, 4)  # => ["a", "b", "c", "d,e"]
p "a,b,c,d,e".split(/,/, 5)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 6)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 7)  # => ["a", "b", "c", "d", "e"]
#@end

#@samplecode limit が負の数の場合は制限なく分割
    p "a,b,c,,,".split(/,/, -1)    # => ["a", "b", "c", "", "", ""]
#@end

@see [[m:String#partition]], [[m:String#rpartition]]

--- squeeze(*chars) -> String

chars に含まれる文字が複数並んでいたら 1 文字にまとめます。

chars の形式は [[man:tr(1)]] と同じです。つまり、
`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外を意味します。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、`^' もその効果は文字列の先頭にあるときだけです。また、
`-', `^', `\' はバックスラッシュ(`\')によ
りエスケープすることができます。

引数を 1 つも指定しない場合は、すべての連続した文字を 1 文字にまとめます。

引数を複数指定した場合は、すべての引数にマッチする文字を 1 文字にまとめます。

@param chars １文字にまとめる文字。

#@samplecode 例
p "112233445566778899".squeeze          # =>"123456789"
p "112233445566778899".squeeze("2-8")   # =>"11234567899"

# 以下の 2 つは同じ意味
p "112233445566778899".squeeze("2378")          # =>"11234455667899"
p "112233445566778899".squeeze("2-8", "^4-6")   # =>"11234455667899"
#@end

--- squeeze!(*chars) -> self | nil

chars に含まれる文字が複数並んでいたら 1 文字にまとめます。

chars の形式は [[man:tr(1)]] と同じです。つまり、
`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外を意味します。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、`^' もその効果は文字列の先頭にあるときだけです。また、
`-', `^', `\' はバックスラッシュ(`\')によ
りエスケープすることができます。

引数を 1 つも指定しない場合は、すべての連続した文字を 1 文字にまとめます。

引数を複数指定した場合は、すべての引数にマッチする文字を 1 文字にまとめます。

1 文字もまとめられなかった場合は nil を返します。

@param chars １文字にまとめる文字。

#@samplecode 例
str = "112233445566778899"
str.squeeze!
p str    # =>"123456789"

str = "112233445566778899"
str.squeeze!("2-8")
p str    # =>"11234567899"

str = "123456789"
str.squeeze! # => nil
p str        # =>"123456789"
#@end

--- strip -> String

文字列先頭と末尾の空白文字を全て取り除いた文字列を生成して返します。
空白文字の定義は " \t\r\n\f\v" です。
また、文字列右側からは "\0" も取り除きますが、
左側の "\0" は取り除きません。

#@samplecode 例
p "  abc  \r\n".strip    #=> "abc"
p "abc\n".strip          #=> "abc"
p "  abc".strip          #=> "abc"
p "abc".strip            #=> "abc"
p "  \0  abc  \0".strip  # => "\000  abc"   # 右側のみ "\0" も取り除く

str = "\tabc\n"
p str.strip              #=> "abc"
p str                    #=> "\tabc\n" (元の文字列は変化しない)
#@end

@see [[m:String#lstrip]], [[m:String#rstrip]]


--- strip! -> self | nil

先頭と末尾の空白文字を全て破壊的に取り除きます。
空白文字の定義は " \t\r\n\f\v" です。
また、文字列右側からは "\0" も取り除きますが、
左側の "\0" は取り除きません。

strip! は、内容を変更した self を返します。
ただし取り除く空白がなかったときは nil を返します。

#@samplecode 例
str = "  abc\r\n"
p str.strip!     #=> "abc"
p str            #=> "abc"

str = "abc"
p str.strip!     #=> nil
p str            #=> "abc"

str = "  \0  abc  \0"
str.strip!
p str            # => "\000  abc"   # 右側の "\0" のみ取り除かれる
#@end

@see [[m:String#strip]], [[m:String#lstrip]]

--- lstrip -> String

文字列の先頭にある空白文字を全て取り除いた新しい文字列を返します。
空白文字の定義は " \t\r\n\f\v" です。

#@samplecode 例
  p "  abc\n".lstrip     #=> "abc\n"
  p "\t abc\n".lstrip    #=> "abc\n"
  p "abc\n".lstrip       #=> "abc\n"
#@end

@see [[m:String#strip]], [[m:String#rstrip]]

--- lstrip! -> self | nil

文字列の先頭にある空白文字を全て破壊的に取り除きます。
空白文字の定義は " \t\r\n\f\v" です。

lstrip! は self を変更して返します。
ただし取り除く空白がなかったときは nil を返します。

#@samplecode 例
str = "  abc"
p str.lstrip!   # => "abc"
p str           # => "abc"

str = "abc"
p str.lstrip!   # => nil
p str           # => "abc"
#@end

--- rstrip -> String

文字列の末尾にある空白文字を全て取り除いた新しい文字列を返します。
空白文字の定義は " \t\r\n\f\v\0" です。

#@samplecode 例
p "  abc\n".rstrip          #=> "  abc"
p "  abc \t\r\n\0".rstrip   #=> "  abc"
p "  abc".rstrip            #=> "  abc"
p "  abc\0 ".rstrip         #=> "  abc"

str = "abc\n"
p str.rstrip    #=> "abc"
p str           #=> "abc\n"  (元の文字列は変化しない)
#@end

@see [[m:String#lstrip]],[[m:String#strip]]

--- rstrip! -> self | nil

文字列の末尾にある空白文字を全て破壊的に取り除きます。
空白文字の定義は " \t\r\n\f\v\0" です。

#@samplecode 例
str = "  abc\n"
p str.rstrip!   # => "  abc"
p str           # => "  abc"

str = "  abc \r\n\t\v\0"
p str.rstrip!   # => "  abc"
p str           # => "  abc"
#@end

@see [[m:String#rstrip]], [[m:String#lstrip]]

--- sub(pattern, replace) -> String

文字列中で pattern にマッチした最初の部分を
文字列 replace で置き換えた文字列を生成して返します。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@param replace    pattern で指定した文字列と置き換える文字列

#@samplecode 例
p 'abcdefg'.sub(/def/, '!!')          # => "abc!!g"
p 'abcabc'.sub(/b/, '<<\&>>')         # => "a<<b>>cabc"
p 'xxbbxbb'.sub(/x+(b+)/, 'X<<\1>>')  # => "X<<bb>>xbb"
#@end

注意:

第 2 引数 replace に [[m:$1]] を埋め込んでも意図した結果にはなりません。
この文字列が評価される時点ではまだ正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、sub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

#@samplecode ひとつめの括弧の内容に置き換えるときによくある間違い
p 'xbbb-xbbb'.sub(/x(b+)/, "#{$1}")   # => "-xbbb"     # NG
p 'xbbb-xbbb'.sub(/x(b+)/, "\1")      # => "1-xbbb"    # NG
p 'xbbb-xbbb'.sub(/x(b+)/, "\\1")     # => "bbb-xbbb"  # OK
p 'xbbb-xbbb'.sub(/x(b+)/, '\1')      # => "bbb-xbbb"  # OK
p 'xbbb-xbbb'.sub(/x(b+)/, '\\1')     # => "bbb-xbbb"  # OK
#@end

#@samplecode バックスラッシュを倍にするときによくある間違い
puts '\n'.sub(/\\/, "\\\\")      # => \n   # NG
puts '\n'.sub(/\\/, '\\\\')      # => \n   # NG
puts '\n'.sub(/\\/, "\\\\\\\\")  # => \\n  # OK
puts '\n'.sub(/\\/, '\\\\\\\\')  # => \\n  # OK
#@end

このような間違いを確実に防止し、コードの可読性を上げるには、
\& や \1 よりも下記のようにブロック付き形式の sub を使うべきです。

#@samplecode 安全な例
p 'xbbb-xbbb'.sub(/x(b+)/) { $1 }   # => "bbb-xbbb"  # OK

puts '\n'.sub(/\\/) { '\\\\' }      # => \\n        # OK
#@end

@see [[m:String#gsub]]

--- sub(pattern) {|matched| .... } -> String

文字列中で pattern にマッチした最初の部分をブロックに渡し、
その評価結果で置き換えた新しい文字列を返します。
ブロックなしの sub と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする

#@samplecode 例
p 'abcabc'.sub(/b/) {|s| s.upcase }  #=> "aBcabc"
p 'abcabc'.sub(/b/) { $&.upcase }    #=> "aBcabc"
#@end

@see [[m:String#gsub]]

--- sub(pattern, hash) -> String

文字列中の pattern にマッチした部分をキーにして hash を引いた値で置き換えます。

@param pattern    置き換える文字列のパターン
@param hash       置き換える文字列を与えるハッシュ

#@samplecode 例
hash = {'b'=>'B', 'c'=>'C'}
p "abcabc".sub(/[bc]/){hash[$&]} #=> "aBCabc"
p "abcabc".sub(/[bc]/, hash)     #=> "aBCabc"
#@end

--- sub!(pattern, replace) -> self | nil

文字列中で pattern にマッチした最初の部分を文字列 replace へ破壊的に置き換えます。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

sub! は通常 self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@param replace    pattern で指定した文字列と置き換える文字列
@return 置換した場合は self、置換しなかった場合は nil

#@samplecode 例
buf = "String-String"
buf.sub!(/in./, "!!")
p buf   # => "Str!!-String"

buf = "String.String"
buf.sub!(/in./, '<<\&>>')
p buf   # => "Str<<ing>>-String"
#@end

注意:

引数 replace の中で [[m:$1]] を使うことはできません。
replace は sub メソッドの呼び出しより先に評価されるので、
まだ sub の正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、sub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

#@samplecode ひとつめの括弧にマッチした部分に置き換えるときによくやる間違いと正しい例
'abbbcd'.sub!(/a(b+)/, "#{$1}")       # NG
'abbbcd'.sub!(/a(b+)/, "\1")          # NG
'abbbcd'.sub!(/a(b+)/, "\\1")         # OK
'abbbcd'.sub!(/a(b+)/, '\\1')         # OK
'abbbcd'.sub!(/a(b+)/, '\1')          # OK
'abbbcd'.sub!(/a(b+)/) { $1 }         # OK   これがもっとも安全
#@end

@see [[m:String#gsub]]

--- sub!(pattern) {|matched| .... } -> self | nil

文字列中で pattern にマッチした最初の部分をブロックに渡し、
その評価結果へ破壊的に置き換えます。

また、ブロックなしの sub と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@param pattern    置き換える文字列のパターンを表す文字列か正規表現。
                  文字列を指定した場合は全く同じ文字列にだけマッチする
@return 置換した場合は self、置換しなかった場合は nil

#@samplecode 例
str = 'abcabc'
str.sub!(/b/) {|s| s.upcase }
p str    #=> "aBcabc"

str = 'abcabc'
str.sub!(/b/) { $&.upcase }
p str    #=> "aBcabc"
#@end

@see [[m:String#gsub]]

--- sub!(pattern, hash) -> String

文字列中の pattern にマッチした部分をキーにして hash を引いた値で破壊的に置き換えます。

@param pattern    置き換える文字列のパターン
@param hash       置き換える文字列を与えるハッシュ
@return 置換した場合は self、置換しなかった場合は nil

--- sum(bits = 16) -> Integer

文字列の bits ビットのチェックサムを計算します。

以下と同じです。

#@samplecode
   def sum(bits)
     sum = 0
     each_byte {|c| sum += c }
     return 0 if sum == 0
     sum & ((1 << bits) - 1)
   end
#@end

例えば以下のコードで UNIX System V の
[[man:sum(1)]] コマンドと同じ値が得られます。

#@samplecode 例
sum = 0
ARGF.each_line do |line|
  sum += line.sum
end
sum %= 65536
#@end

@param bits    チェックサムのビット数

#@since 2.4.0
--- swapcase(*options) -> String

大文字を小文字に、小文字を大文字に変更した文字列を返します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- swapcase -> String

'A' から 'Z' までのアルファベット大文字を小文字に、
'a' から 'z' までのアルファベット小文字を大文字に変更した文字列を返します。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。
#@end

#@samplecode 例
p "ABCxyz".swapcase   # => "abcXYZ"
p "Access".swapcase   # => "aCCESS"
#@end

@see [[m:String#swapcase!]], [[m:String#upcase]], [[m:String#downcase]], [[m:String#capitalize]]

#@since 2.4.0
--- swapcase!(*options) -> self | nil

大文字を小文字に、小文字を大文字に破壊的に変更します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- swapcase! -> self | nil

'A' から 'Z' までのアルファベット大文字を小文字に、
'a' から 'z' までのアルファベット小文字を大文字に、破壊的に変更します。
#@end

swapcase! は self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

このメソッドはマルチバイト文字を認識しません。

#@samplecode 例
str = "ABCxyz"
str.swapcase!
p str   # => "abcXYZ"
#@end

@see [[m:String#swapcase]], [[m:String#upcase!]], [[m:String#downcase!]], [[m:String#capitalize!]]

--- to_f -> Float

文字列を 10 進数表現と解釈して、浮動小数点数 [[c:Float]] に変換します。

浮動小数点数とみなせなくなるところまでを変換対象とします。
変換対象が空文字列であれば 0.0 を返します。

#@samplecode 例
p "10".to_f    # => 10.0
p "10e2".to_f  # => 1000.0
p "1e-2".to_f  # => 0.01
p ".1".to_f    # => 0.1

p "nan".to_f   # => 0.0
p "INF".to_f   # => 0.0
p "-Inf".to_f  # => -0.0
p(("10" * 1000).to_f)   # => Infinity (with warning)

p "".to_f      # => 0.0
p "1_0_0".to_f # => 100.0
p " \n10".to_f # => 10.0       # 先頭の空白は無視される
p "0xa.a".to_f # => 0.0
#@end

なお、このメソッドの逆に、数値を文字列に変換するには
[[m:Kernel.#sprintf]],[[m:String#%]],[[m:Integer#to_s]]
を使用します。

@see [[m:String#hex]], [[m:String#oct]], [[m:String#to_i]],
     [[m:Kernel.#Integer]], [[m:Kernel.#Float]]

--- to_i(base = 10) -> Integer

文字列を 10 進数表現された整数であると解釈して、整数に変換します。

#@samplecode 例
  p " 10".to_i    # => 10
  p "+10".to_i    # => 10
  p "-10".to_i    # => -10

  p "010".to_i    # => 10
  p "-010".to_i   # => -10
#@end

整数とみなせない文字があればそこまでを変換対象とします。
変換対象が空文字列であれば 0 を返します。

#@samplecode 例
  p "0x11".to_i   # => 0
  p "".to_i       # => 0
#@end

基数を指定することでデフォルトの 10 進以外に 2 〜 36 進数表現へ変換できます。
それぞれ Ruby の整数リテラルで使用可能なプリフィクスは無視されます。
また、base に 0 を指定するとプリフィクスから基数を判断します。
認識できるプリフィクスは、
0b (2 進数)、0 (8 進数)、0o (8 進数)、0d (10 進数)、0x (16 進数) です。

0, 2 〜 36 以外の引数を指定した場合は
例外 [[c:ArgumentError]] が発生します。

#@samplecode 例
  p "01".to_i(2)    # => 1
  p "0b1".to_i(2)   # => 1

  p "07".to_i(8)    # => 7
  p "0o7".to_i(8)   # => 7

  p "1f".to_i(16)   # => 31
  p "0x1f".to_i(16) # => 31

  p "0b10".to_i(0)  # => 2
  p "0o10".to_i(0)  # => 8
  p "010".to_i(0)   # => 8
  p "0d10".to_i(0)  # => 10
  p "0x10".to_i(0)  # => 16
#@end

@param base    進数を指定する整数。0 か、2〜36 の整数。
@return        整数

このメソッドの逆に数値を文字列に変換するには、
[[m:Kernel.#sprintf]], [[m:String#%]], [[m:Integer#to_s]]
を使用します。

[[m:String#hex]], [[m:String#oct]], [[m:String#to_f]],
[[m:Kernel.#Integer]], [[m:Kernel.#Float]]
も参照してください。

--- to_s -> String
--- to_str -> String

self を返します。

#@samplecode 例
    p "str".to_s     # => "str"
    p "str".to_str   # => "str"
#@end

このメソッドは、文字列を他のクラスのインスタンスと混ぜて処理したいときに有効です。
例えば返り値が文字列か nil であるメソッド some_method があるとき、
to_s メソッドを使うと以下のように統一的に処理できます。

#@samplecode 例
    # some_method(5).downcase だと返り値が nil のときに
    # エラーになるので to_s をはさむ
    p some_method(5).to_s.downcase
#@end

--- tr(pattern, replace) -> String

pattern 文字列に含まれる文字を検索し、
それを replace 文字列の対応する文字に置き換えます。

pattern の形式は [[man:tr(1)]] と同じです。つまり、
`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外が置換の対象になります。

replace に対しても `-' による範囲指定が可能です。
例えば [[m:String#upcase]] は tr を使って
"foo".tr('a-z', 'A-Z') と書けます。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
`^' も文字列の先頭にあるときにだけ否定の効果を発揮します。
また、`-', `^', `\' はバックスラッシュ (`\') によりエスケープできます。

replace の範囲が pattern の範囲よりも小さい場合は、
replace の最後の文字が無限に続くものとして扱われます。

@param pattern    置き換える文字のパターン
@param replace    pattern で指定した文字を置き換える文字

#@samplecode 例
    p "foo".tr("f", "X")      # => "Xoo"
    p "foo".tr('a-z', 'A-Z')  # => "FOO"
    p "FOO".tr('A-Z', 'a-z')  # => "foo"
#@end

@see [[m:String#tr_s]]

--- tr!(pattern, replace) -> self | nil

pattern 文字列に含まれる文字を検索し、
それを replace 文字列の対応する文字に破壊的に置き換えます。

pattern の形式は [[man:tr(1)]] と同じです。
つまり、`a-c' は a から c を意味し、
"^0-9" のように文字列の先頭が `^' の場合は
指定文字以外が置換の対象になります。

replace に対しても `-' による範囲指定が可能です。
例えば、[[m:String#upcase]] を tr! で書くと、

#@samplecode
str = "foo"
p str.tr!('a-z', 'A-Z') #=> "FOO"
p str                   #=> "FOO"
#@end

となります。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
`^' も文字列の先頭にあるときにだけ否定の効果を発揮します。
また、`-', `^', `\' はバックスラッシュ (`\') によりエスケープできます。

replace の範囲が pattern の範囲よりも小さい場合は、
replace の最後の文字が無限に続くものと扱われます。

tr! は self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@param pattern    置き換える文字のパターン
@param replace    pattern で指定した文字を置き換える文字

@see [[m:String#tr]], [[m:String#tr_s]]

--- tr_s(pattern, replace) -> String

文字列の中に pattern 文字列に含まれる文字が存在したら、
replace 文字列の対応する文字に置き換えます。さらに、
置換した部分内に同一の文字の並びがあったらそれを 1 文字に圧縮します。

pattern の形式は [[man:tr(1)]] と同じです。
つまり「a-c」は a から c を意味し、
"^0-9" のように文字列の先頭が「^」の場合は指定した文字以外が置換の対象になります。

replace でも「-」を使って範囲を指定できます。

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、「^」もその効果は文字列の先頭にあるときだけです。
また、「-」、「^」、「\」はバックスラッシュ (「\」) でエスケープできます。

replace の範囲が pattern の範囲よりも小さい場合、
replace の最後の文字が無限に続くものとして扱われます。

@param pattern    置き換える文字のパターン
@param replace    pattern で指定した文字を置き換える文字

#@samplecode 例
p "gooooogle".tr_s("o", "X")       # => "gXgle"
p "gooooogle".tr_s("a-z", "A-Z")   # => "GOGLE"
#@end

注意:
一般に、tr_s を tr と squeeze で置き換えることはできません。
tr と squeeze の組みあわせでは tr の置換後の文字列全体を squeeze しますが、
tr_s は置換された部分だけを squeeze します。
以下のコードを参照してください。

#@samplecode 例
p "foo".tr_s("o", "f")              # => "ff"
p "foo".tr("o", "f").squeeze("f")   # => "f"
#@end

@see [[m:String#tr]]

--- tr_s!(pattern, replace) -> self | nil

文字列の中に pattern 文字列に含まれる文字が存在したら、
replace 文字列の対応する文字に置き換えます。さらに、
置換した部分内に同一の文字の並びがあったらそれを 1 文字に圧縮します。

pattern の形式は [[man:tr(1)]] と同じです。
つまり「a-c」は a から c を意味し、
"^0-9" のように文字列の先頭が「^」の場合は指定した文字以外が置換の対象になります。

replace でも「-」を使って範囲を指定できます。

#@samplecode
  p "gooooogle".tr_s("a-z", "A-Z")   # => "GOGLE"
#@end

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、「^」もその効果は文字列の先頭にあるときだけです。
また、「-」、「^」、「\」はバックスラッシュ (「\」) でエスケープできます。

replace の範囲が search の範囲よりも小さい場合、
replace の最後の文字が無限に続くものとして扱われます。

tr_s は置換後の文字列を生成して返します。
tr_s! は self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

注意:
一般に、tr_s! を tr! と squeeze! で置き換えることはできません。
tr! と squeeze! の組みあわせでは tr! の置換後の文字列全体を squeeze! しますが、
tr_s! は置換された部分だけを squeeze! します。
以下のコードを参照してください。

#@samplecode 例
str = "foo"
str.tr_s!("o", "f")
p str   # => "ff"

str = "foo"
str.tr!("o", "f")
str.squeeze!("f")
p str   # => "f"
#@end

@param pattern    置き換える文字のパターン
@param replace    pattern で指定した文字を置き換える文字

@see [[m:String#tr]], [[m:String#tr_s]]

--- unpack(template) -> Array

[[m:Array#pack]] で生成された文字列を
テンプレート文字列 template にしたがってアンパックし、
それらの要素を含む配列を返します。

@param template    pack テンプレート文字列
@return            オブジェクトの配列

#@include(pack-template)

#@since 2.4.0
--- upcase(*options) -> String

全ての小文字を対応する大文字に置き換えた文字列を返します。
どの文字がどう置き換えられるかは、オプションの有無や文字列のエンコーディングに依存します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- upcase -> String

'a' から 'z' までのアルファベット小文字を大文字に変換した文字列を作成して返します。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。
#@end

#@samplecode 例
p "stRIng? STring.".upcase   # => "STRING? STRING."
#@end

@see [[m:String#upcase!]], [[m:String#downcase]],
     [[m:String#swapcase]], [[m:String#capitalize]]

#@since 2.4.0
--- upcase!(*options) -> self | nil

全ての小文字を対応する大文字に破壊的に置き換えます。
どの文字がどう置き換えられるかは、オプションの有無や文字列のエンコーディングに依存します。

@param options オプションの詳細は [[m:String#downcase]] を参照してください。
#@else
--- upcase! -> self | nil

ASCII 文字列の範囲内で 'a' から 'z' までの
アルファベット小文字を全て大文字にします。
このメソッドは self を破壊的に変更して返しますが、
置換が起こらなかった場合は nil を返します。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。
#@end

#@samplecode 例
buf = "stRIng? STring."
buf.upcase!
p buf   # => "STRING? STRING."
#@end

@see [[m:String#upcase]], [[m:String#downcase!]],
     [[m:String#swapcase!]], [[m:String#capitalize!]]

--- upto(max, exclusive = false) {|s| ... } -> self

self から始めて max まで
「次の文字列」を順番にブロックに与えて繰り返します。
「次」の定義については [[m:String#succ]] を参照してください。

たとえば以下のコードは a, b, c, ... z, aa, ... az, ..., za を
出力します。

#@samplecode
  ("a" .. "za").each do |str|
    puts str
  end
  'a'.upto('za') do |str|
    puts str
  end
#@end

@param max    繰り返しをやめる文字列

@param exclusive max を含むかどうか。false の場合は max を含む。

--- eql?(other) -> bool

文字列の内容が文字列 other の内容と等しいときに true を返します。
等しくなければ false を返します。

このメソッドは文字列の内容を比較します。
同一のオブジェクトかどうかを比較するわけではありません。
つまり、"string".eql?(str) という式を実行した場合には、
str が "string" という内容の文字列でありさえすれば常に true を返します。
同一のオブジェクトであるかどうかを判定したいときは
[[m:Object#equal?]] を使ってください。

アルファベットの大文字小文字を無視して比較したい場合は、[[m:String#upcase]],
[[m:String#downcase]] で大文字小文字を揃えてから比較してください。

[[c:Hash]] クラス内での比較に使われます。

@param other    任意のオブジェクト
@return         true か false

#@samplecode 例
p "string".eql?("string")  # => true
p "string".eql?("STRING")  # => false
p "string".eql?("")        # => false
p "".eql?("string")        # => false

p "string".eql?("str" + "ing")   # => true   (内容が同じなら true)
p "string".eql?("stringX".chop)  # => true   (内容が同じなら true)

p "string".upcase.eql?("String".upcase)     # => true
p "string".downcase.eql?("String".downcase) # => true
#@end

@see [[c:Hash]], [[m:String#<=>]], [[m:String#casecmp]], [[m:String#==]]

--- hash -> Integer

self のハッシュ値を返します。
eql? で等しい文字列は、常にハッシュ値も等しくなります。

#@samplecode 例
"test".hash                        # => 4038258770210371295
("te" + "st").hash == "test".hash  # => true
#@end

@see [[c:Hash]]

--- inspect -> String

文字列オブジェクトの内容を、出力したときに人間が読みやすいような適当な形式に変換します。
変換された文字列は印字可能な文字のみによって構成されます

現在の実装では、Ruby のリテラル形式を使って、
文字列中の不可視文字をエスケープシーケンスに変換します。

このメソッドは主にデバッグのために用意されています。
永続化などの目的で文字列をダンプしたいときは、
[[m:String#dump]] を使うべきです。

#@samplecode 例
# p ではないことに注意
puts "string".inspect    # => "string"
puts "\t\r\n".inspect    # => "\t\r\n"
#@end

@see [[m:String#dump]]

--- chr -> String

self の最初の文字だけを含む文字列を返します。

#@samplecode 例
a = "abcde"
a.chr    #=> "a"
#@end

Ruby 1.9 で IO#getc の戻り値が Integer から String を返すように変更になりました。
Ruby 1.8 以前と1.9以降の互換性を保つために  String#chr が存在します。

例:
  # ruby 1.8 系では STDIN.getc が 116 を返すため Integer#chr が呼び出される
  $ echo test | ruby -e "p STDIN.getc.chr" # => "t"
  # ruby 1.9 系以降では STDIN.getc が "t" を返すため String#chr が呼び出される
  $ echo test | ruby -e "p STDIN.getc.chr" # => "t"

@see [[m:String#ord]], [[m:Integer#chr]]

#@since 2.5.0
--- start_with?(*prefixes) -> bool

self の先頭が prefixes のいずれかであるとき true を返します。

@param prefixes パターンを表す文字列または正規表現 (のリスト)
#@else
--- start_with?(*strs) -> bool

self の先頭が strs のいずれかであるとき true を返します。

@param strs    パターンを表す文字列 (のリスト)
#@end

#@samplecode 例
"string".start_with?("str")          # => true
"string".start_with?("ing")          # => false
"string".start_with?("ing", "str")   # => true
#@since 2.5.0
"string".start_with?(/\w/)           # => true
"string".start_with?(/\d/)           # => false
#@end
#@end

@see [[m:String#end_with?]]
#@since 2.5.0
@see [[m:String#delete_prefix]], [[m:String#delete_prefix!]]
#@end

--- end_with?(*strs) -> bool

self の末尾が strs のいずれかであるとき true を返します。

@param strs    パターンを表す文字列 (のリスト)

#@samplecode 例
"string".end_with?("ing")          # => true
"string".end_with?("str")          # => false
"string".end_with?("str", "ing")   # => true
#@end

@see [[m:String#start_with?]]
#@since 2.5.0
@see [[m:String#delete_suffix]], [[m:String#delete_suffix!]]
#@end

--- partition(sep) -> [String, String, String]

セパレータ sep が最初に登場する部分で self を 3 つに分割し、
[最初のセパレータより前の部分, セパレータ, それ以降の部分]
の 3 要素の配列を返します。

self がセパレータを含まないときは、
返り値の第 2 要素と第 3 要素が空文字列になります。

@param sep    セパレータを表す文字列か正規表現を指定します。

#@samplecode 例
p "axaxa".partition("x")   # => ["a", "x", "axa"]
p "aaaaa".partition("x")   # => ["aaaaa", "", ""]
p "aaaaa".partition("")    # => ["", "", "aaaaa"]
#@end

@see [[m:String#rpartition]], [[m:String#split]]

--- rpartition(sep) -> [String, String, String]

セパレータ sep が最後に登場する部分で self を 3 つに分割し、
[最後のセパレータより前の部分, セパレータ, それ以降の部分]
の 3 要素の配列を返します。

self がセパレータを含まないときは、
返り値の第 1 要素と第 2 要素が空文字列になります。

@param sep    セパレータを表す文字列か正規表現を指定します。

#@samplecode 例
p "axaxa".rpartition("x")   # => ["axa", "x", "a"]
p "aaaaa".rpartition("x")   # => ["", "", "aaaaa"]
#@end

@see [[m:String#partition]], [[m:String#split]]

--- each_char {|cstr| block } -> self
--- each_char -> Enumerator

文字列の各文字に対して繰り返します。

たとえば、
#@samplecode
"hello世界".each_char {|c| print c, ' ' }
#@end
は次のように出力されます。
  h e l l o 世 界

@see [[m:String#chars]]

--- chars                 -> [String]
--- chars {|cstr| block } -> self

文字列の各文字を文字列の配列で返します。(self.each_char.to_a と同じです)

#@samplecode 例
  "hello世界".chars # => ["h", "e", "l", "l", "o", "世", "界"]
#@end

ブロックが指定された場合は [[m:String#each_char]] と同じように動作しま
す。ただし obsolete のため、ブロックを指定する場合は
[[m:String#each_char]] を使用してください。

@see [[m:String#each_char]]

--- each_codepoint {|codepoint| block } -> self
--- each_codepoint -> Enumerator

文字列の各コードポイントに対して繰り返します。

UTF-8/UTF-16(BE|LE)/UTF-32(BE|LE) 以外のエンコーディングに対しては
各文字のバイナリ表現由来の値になります。

#@samplecode 例
#coding:UTF-8
"hello わーるど".each_codepoint.to_a
# => [104, 101, 108, 108, 111, 32, 12431, 12540, 12427, 12393]
"hello わーるど".encode('euc-jp').each_codepoint.to_a
# => [104, 101, 108, 108, 111, 32, 42223, 41404, 42219, 42185]
#@end

@see [[m:String#codepoints]]

--- codepoints                      -> [Integer]
--- codepoints {|codepoint| block } -> self

文字列の各コードポイントの配列を返します。(self.each_codepoint.to_a と同じです)

#@samplecode 例
#coding:UTF-8
"hello わーるど".codepoints
# => [104, 101, 108, 108, 111, 32, 12431, 12540, 12427, 12393]
#@end

ブロックが指定された場合は [[m:String#each_codepoint]] と同じように動作
します。ただし obsolete のため、ブロックを指定する場合は
[[m:String#each_codepoint]] を使用してください。

@see [[m:String#each_codepoint]]

--- bytesize -> Integer

文字列のバイト長を整数で返します。

#@samplecode 例
#coding:UTF-8
# 実行結果は文字コードによって異なります。
p "いろは".size     #=> 3
p "いろは".bytesize #=> 9
#@end

@see [[m:String#size]]

--- ord -> Integer

文字列の最初の文字の文字コードを整数で返します。

self が空文字列のときは例外を発生します。

@return                 文字コードを表す整数
@raise ArgumentError    self の長さが 0 のとき発生

#@samplecode 例
p "a".ord   # => 97
#@end

@see [[m:Integer#chr]], [[m:String#chr]]

--- encoding   -> Encoding

文字列のエンコーディング情報を表現した Encoding オブジェクトを返します。

#@samplecode 例
# encoding: utf-8
utf8_str = "test"
euc_str = utf8_str.encode("EUC-JP")
utf8_str.encoding   # => #<Encoding:UTF-8>
euc_str.encoding    # => #<Encoding:EUC-JP>
#@end

@see [[c:Encoding]]

--- force_encoding(encoding)   -> self

文字列の持つエンコーディング情報を指定された encoding に変えます。

このとき実際のエンコーディングは変換されず、検査もされません。
[[m:Array#pack]] などで得られたバイト列のエンコーディングを指定する時に使います。

@param encoding   変更するエンコーディング情報を表す文字列か Encoding オブジェクトを指定します。

#@samplecode 例
s = [164, 164, 164, 237, 164, 207].pack("C*")
p s.encoding                                  #=> ASCII-8BIT
p s.force_encoding("EUC-JP")                  #=> "いろは"

u = [12411, 12408, 12392].pack("U*")
u.force_encoding("UTF-8")                     #=> "ほへと"
#@end

--- ascii_only?  -> bool

文字列がASCII文字のみで構成されている場合に true を返します。さもなくば
false を返します。

例:

  'abc123'.ascii_only?        # => true
  ''.ascii_only?              # => true
  '日本語'.ascii_only?        # => false
  '日本語abc123'.ascii_only?  # => false

--- valid_encoding?  -> bool

文字列の内容が、現在のエンコーディングに照らしあわせて妥当であれば
true を返します。さもなくば false を返します。

#@samplecode 例
"\xc2\xa1".force_encoding("UTF-8").valid_encoding?  #=> true
"\xc2".force_encoding("UTF-8").valid_encoding?      #=> false
"\x80".force_encoding("UTF-8").valid_encoding?      #=> false
#@end

--- encode(encoding, options = nil) -> String
--- encode(encoding, from_encoding, options = nil) -> String
--- encode(options = nil) -> String

self を指定したエンコーディングに変換した文字列を作成して返します。引数
を2つ与えた場合、第二引数は変換元のエンコーディングを意味します。さもな
くば self のエンコーディングが使われます。
無引数の場合は、[[m:Encoding.default_internal]] が nil でなければそれが変換先のエンコーディングになり、かつ :invalid => :replace と :undef => :replace が指定されたと見なされ、nil ならば変換は行われません。

@param encoding       変換先のエンコーディングを表す文字列か [[c:Encoding]] オブジェクトを指定します。
@param from_encoding  変換元のエンコーディングを表す文字列か [[c:Encoding]] オブジェクトを指定します。
@param option         変換オプションをハッシュで与えます。
@return               変換された文字列

変換オプション

: :invalid => nil
  変換元のエンコーディングにおいて不正なバイトがあった場合に、例外 [[c:Encoding::InvalidByteSequenceError]] を投げます。(デフォルト)
: :invalid => :replace
  変換元のエンコーディングにおいて不正なバイトがあった場合に、不正なバイトを置換文字で置き換えます。
: :undef => nil
  変換先のエンコーディングにおいて文字が定義されていない場合に、例外 [[c:Encoding::UndefinedConversionError]] を投げます。(デフォルト)
: :undef => :replace
  変換先のエンコーディングにおいて文字が定義されていない場合に、未定義文字を置換文字で置き換えます。
: :replace => string
  前述の :invalid => :replace や :undef => :replace で用いられる置換文字を指定します。デフォルトは Unicode 系のエンコーディングならば U+FFFD、それ以外では "?" です。
: :fallback => Hash | Proc | Method
  未定義の文字に対する置換文字を設定します。このオプションに与えられるオブジェクトは [[c:Hash]], [[c:Proc]], [[c:Method]] のいずれかまたは [] メソッドを持つオブジェクトです。
  キーは現在のトランスコーダのソースエンコーディングで未定義の文字です。値は、変換先のエンコーディングでの変換後の文字です。
: :xml => :text
  文字列を XML の CharData として適するように処理します。具体的には、'&'、'<'、'>'、をそれぞれ '&amp;'、'&lt;'、'&gt;' に変換し、未定義文字を文字参照 (大文字16進数) に置き換えます。この出力は HTML の #PCDATA として利用することもできます。
: :xml => :attr
  文字列を XML の AttValue として適するように処理します。具体的には、'&'、'<'、'>'、'"'、をそれぞれ '&amp;'、'&lt;'、'&gt;'、'&quot;' に変換し、未定義文字を文字参照 (大文字16進数) に置き換えます。この出力は HTML の属性値として利用することもできます。
: :universal_newline => true
  CR 改行および CRLF 改行を LF 改行に置き換えます。
: :cr_newline => true
  LF 改行を CR 改行に置き換えます。(CRLF は CRCR になります)
: :crlf_newline => true
  LF 改行を CRLF 改行に置き換えます。(CRLF は CRCRLF になります)

これ以上細かい指定を行いたい場合は、[[m:Encoding::Converter#convert]] を用いましょう。

#@samplecode 例
#coding:UTF-8
s = "いろは"
s.encode("EUC-JP")
s.encode(Encoding::UTF_8)

# U+00B7 MIDDLE DOT, U+2014 EM DASH は対応する文字が Windows-31J には
# 存在しないのでそのまま変換しようとすると Encoding::UndefinedConversionError が発生する
str = "\u00b7\u2014"
str.encode("Windows-31J", fallback: { "\u00b7" => "\xA5".force_encoding("Windows-31J"),
                                      "\u2014" => "\x81\x5C".force_encoding("Windows-31J") })
#@end

@see [[m:String#encode!]]

--- encode!(encoding, options = nil)                -> self
--- encode!(encoding, from_encoding, options = nil) -> self

self を指定したエンコーディングに変換し、自身を置き換えます。引数を2つ
与えた場合、第二引数は変換元のエンコーディングを意味します。さもなくば
self のエンコーディングが使われます。変換後の self を返します。

(gsub!などと異なり)変換が行なわれなくても self を返します。

@param encoding       変換先のエンコーディングを表す文字列か Encoding オブジェクトを指定します。
@param from_encoding  変換元のエンコーディングを表す文字列か Encoding オブジェクトを指定します。
@return               変換後のself

#@samplecode 例
#coding:UTF-8
s = "いろは"
s.encode!("EUC-JP")
s.encode!(Encoding::UTF_8)
#@end

@see [[m:String#encode]]

--- to_c -> Complex

自身を複素数 ([[c:Complex]]) に変換した結果を返します。

以下の形式を解析できます。i、j は大文字、小文字のどちらでも解析できます。

 * 実部+虚部i
 * 実部+虚部j
 * 絶対値@偏角

それぞれの数値は以下のいずれかの形式で指定します。先頭の空白文字や複素
数値の後にある文字列は無視されます。また、数値オブジェクトと同様に各桁
の間に「_」を入れる事ができます。

 * "1/3" のような分数の形式
 * "0.3" のような10進数の形式
 * "0.3E0" のような x.xEn の形式

自身が解析できない値であった場合は 0+0i を返します。

#@samplecode 例
'9'.to_c           # => (9+0i)
'2.5'.to_c         # => (2.5+0i)
'2.5/1'.to_c       # => ((5/2)+0i)
'-3/2'.to_c        # => ((-3/2)+0i)
'-i'.to_c          # => (0-1i)
'45i'.to_c         # => (0+45i)
'3-4i'.to_c        # => (3-4i)
'-4e2-4e-2i'.to_c  # => (-400.0-0.04i)
'-0.0-0.0i'.to_c   # => (-0.0-0.0i)
'1/2+3/4i'.to_c    # => ((1/2)+(3/4)*i)
'10@10'.to_c       # => (-8.390715290764524-5.440211108893697i)
'-0.3_3'.to_c      # => (-0.33+0i)
" \t\r\n5+3i".to_c # => (5+3i)
'5+3ix'.to_c       # => (5+3i)
'ruby'.to_c        # => (0+0i)
#@end

--- to_r -> Rational

自身を有理数([[c:Rational]])に変換した結果を返します。

[[m:Kernel.#Rational]] に文字列を指定した時のように、以下のいずれかの形
式で指定します。

 * "1/3" のような分数の形式
 * "0.3" のような10進数の形式
 * "0.3E0" のような x.xEn の形式
 * 数字をアンダースコアで繋いだ形式

#@samplecode 例
'  2  '.to_r       # => (2/1)
'1/3'.to_r         # => (1/3)
'-9.2'.to_r        # => (-46/5)
'-9.2E2'.to_r      # => (-920/1)
'1_234_567'.to_r   # => (1234567/1)
'1_234/5_678'.to_r # => (617/2839)
#@end

[[m:Kernel.#Rational]] に文字列を指定した時とは異なる点もあります。

途中に変換できないような文字列が入っていた場合は、それより先の文字列は
無視されます。

#@samplecode
'21 june 09'.to_r  # => (21/1)
'21/06/09'.to_r    # => (7/2)   # 21/6 を約分して 7/2。
#@end

変換できないような文字列を指定した場合は 0/1 を返します。

#@samplecode
'foo'.to_r         # => (0/1)
''.to_r            # => (0/1)
'bwv 1079'.to_r    # => (0/1)
#@end

@see [[m:Kernel.#Rational]]

--- byteslice(nth)         -> String | nil

nth バイト目の文字を返します。nth が負の場合は文字列の末尾から数えます。
引数が範囲外を指定した場合は nil を返します。

@param nth 文字の位置を表す整数を指定します。

@return 切り出した文字列を返します。戻り値の文字エンコーディングは自身
        と同じです。

#@samplecode 例
"hello".byteslice(1)  # => "e"
"hello".byteslice(-1) # => "o"
"\u3042".byteslice(0) # => "\xE3"
"\u3042".byteslice(1) # => "\x81"
#@end

@see [[m:String#slice]]

--- byteslice(nth, len) -> String | nil

nth バイト目から長さ len バイトの部分文字列を新しく作って返します。
nth が負の場合は文字列の末尾から数えます。引数が範囲外を指定した場合は
nil を返します。

@param nth 取得したい文字列の開始バイトを整数で指定します。

@param len 取得したい文字列の長さを正の整数で指定します。

@return 切り出した文字列を返します。戻り値の文字エンコーディングは自身
        と同じです。

#@samplecode 例
"hello".byteslice(1, 2)              # => "el"
"\u3042\u3044\u3046".byteslice(0, 3) # => "\u3042"
#@end

@see [[m:String#slice]]

--- byteslice(range)          -> String | nil

range で指定したバイトの範囲に含まれる部分文字列を返します。引数が範囲
外を指定した場合は nil を返します。

@param range 取得したい文字列の範囲を示す Range オブジェクト

@return 切り出した文字列を返します。戻り値の文字エンコーディングは自身
        と同じです。

#@samplecode 例
"hello".byteslice(1..2)          # => "el"
"\x03\u3042\xff".byteslice(1..3) # => "\u3042"
#@end

@see [[m:String#slice]]

--- prepend(other_str) -> String
文字列 other_str を先頭に破壊的に追加します。

@param other_str 追加したい文字列を指定します。

例:
  a = "world"
  a.prepend("hello ") # => "hello world"
  a                   # => "hello world"

#@since 2.4.0
--- prepend(*arguments) -> String
複数の文字列を先頭に破壊的に追加します。

@param arguments 追加したい文字列を指定します。

#@samplecode 例
a = "!!!"
a.prepend # => "!!!"
a         # => "!!!"

a = "!!!"
a.prepend "hello ", "world" # => "hello world!!!"
a                           # => "hello world!!!"
#@end
#@end

--- b -> String

self の文字エンコーディングを ASCII-8BIT にした文字列の複製を返します。

#@samplecode 例
'abc123'.encoding    # => #<Encoding:UTF-8>
'abc123'.b.encoding  # => #<Encoding:ASCII-8BIT>
#@end

#@since 2.1.0
--- scrub               -> String
--- scrub(repl)         -> String
--- scrub{|bytes| ... } -> String

self が不正なバイト列を含む場合に別の文字列に置き換えた新しい文字列を返します。

@param repl 不正なバイト列を置き換える文字列を指定します。省略した場合
            は self の文字エンコーディングが [[m:Encoding::UTF_16BE]],
            [[m:Encoding::UTF_16LE]], [[m:Encoding::UTF_32BE]],
            [[m:Encoding::UTF_32LE]], [[m:Encoding::UTF_8]] のいずれか
            の場合は "\uFFFD" を表す文字で、それ以外の場合は "?" で置き
            換えられます。ブロックが指定された場合は不正なバイト列はブ
            ロックの戻り値で置き換えられます。

#@samplecode 例
"abc\u3042\x81".scrub      # => "abc\u3042\uFFFD"
"abc\u3042\x81".scrub("*") # => "abc\u3042*"
"abc\u3042\xE3\x80".scrub{|bytes| '<'+bytes.unpack('H*')[0]+'>' } # => "abc\u3042<e380>"
#@end

@see [[m:String#scrub!]]

--- scrub!               -> String
--- scrub!(repl)         -> String
--- scrub!{|bytes| ... } -> String

self が不正なバイト列を含む場合に別の文字列に置き換えます。常に self を返します。

@param repl 不正なバイト列を置き換える文字列を指定します。省略した場合
            は self の文字エンコーディングが [[m:Encoding::UTF_16BE]],
            [[m:Encoding::UTF_16LE]], [[m:Encoding::UTF_32BE]],
            [[m:Encoding::UTF_32LE]], [[m:Encoding::UTF_8]] のいずれか
            の場合は "\uFFFD" を表す文字で、それ以外の場合は "?" で置き
            換えられます。ブロックが指定された場合は不正なバイト列はブ
            ロックの戻り値で置き換えられます。

#@samplecode 例
"abc\u3042\x81".scrub!      # => "abc\u3042\uFFFD"
"abc\u3042\x81".scrub!("*") # => "abc\u3042*"
"abc\u3042\xE3\x80".scrub!{|bytes| '<'+bytes.unpack('H*')[0]+'>' } # => "abc\u3042<e380>"
#@end

@see [[m:String#scrub]]
#@end

#@since 2.2.0
--- unicode_normalize(form = :nfc) -> String

self を NFC、NFD、NFKC、NFKD のいずれかの正規化形式で Unicode 正規化し
た文字列を返します。

@param form 正規化形式を :nfc、:nfd、:nfkc、:nfkd のいずれかで指定しま
            す。省略した場合は :nfc になります。

@raise Encoding::CompatibilityError self が Unicode 文字列ではない場合
                                    に発生します。

このメソッドでの "Unicode 文字列" とは、UTF-8、UTF-16BE/LE、
UTF-32BE/LE だけではなく GB18030、UCS_2BE、and UCS_4BE を含みます。

また、self が UTF-8 以外のエンコーディングであった場合は一度 UTF-8 に変
換してから正規化されるため、UTF-8 よりも遅くなっています。

#@samplecode 例
"a\u0300".unicode_normalize        # => 'à' ("\u00E0" と同じ)
"a\u0300".unicode_normalize(:nfc)  # => 'à' ("\u00E0" と同じ)
"\u00E0".unicode_normalize(:nfd)   # => 'à' ("a\u0300" と同じ)
"\xE0".force_encoding('ISO-8859-1').unicode_normalize(:nfd)
                                   # => Encoding::CompatibilityError raised
#@end

@see [[m:String#unicode_normalize!]], [[m:String#unicode_normalized?]]

--- unicode_normalize!(form = :nfc) -> self

self を NFC、NFD、NFKC、NFKD のいずれかの正規化形式で Unicode 正規化し
た文字列に置き換えます。

(gsub!などと異なり)変換が行なわれなくても self を返します。

@param form 正規化形式を :nfc、:nfd、:nfkc、:nfkd のいずれかで指定しま
            す。省略した場合は :nfc になります。

@raise Encoding::CompatibilityError self が Unicode 文字列ではない場合
                                    に発生します。

#@samplecode 例
text = "a\u0300"
text.unicode_normalize!(:nfc)
text == "\u00E0"              # => true
text.unicode_normalize!(:nfd)
text == "a\u0300"             # => true
#@end

@see [[m:String#unicode_normalize]], [[m:String#unicode_normalized?]]

--- unicode_normalized?(form = :nfc) -> bool

self が引数 form で指定された正規化形式で Unicode 正規化された文字列か
どうかを返します。

@param form 正規化形式を :nfc、:nfd、:nfkc、:nfkd のいずれかで指定しま
            す。省略した場合は :nfc になります。

@raise Encoding::CompatibilityError self が Unicode 文字列ではない場合
                                    に発生します。

#@samplecode 例
"a\u0300".unicode_normalized?        # => false
"a\u0300".unicode_normalized?(:nfd)  # => true
"\u00E0".unicode_normalized?         # => true
"\u00E0".unicode_normalized?(:nfd)   # => false
"\xE0".force_encoding('ISO-8859-1').unicode_normalized?
                                     # => Encoding::CompatibilityError raised
#@end

@see [[m:String#unicode_normalize]], [[m:String#unicode_normalize!]]
#@end
#@since 2.4.0
--- unpack1(format) -> object

formatにしたがって文字列をデコードし、展開された1つ目の値を返します。
unpackは配列を返しますがunpack1は配列の1つ目の要素のみを返します。

#@samplecode 例
"ABC".unpack1("C*") # => 65
"ABC".unpack("C*")  # => [65, 66, 67]
#@end

@see [[m:String#unpack]], [[m:Array#pack]]
#@end
#@since 2.5.0
--- each_grapheme_cluster {|grapheme_cluster| block } -> self
--- each_grapheme_cluster -> Enumerator

文字列の書記素クラスタに対して繰り返します。

[[m:String#each_char]] と違って、
Unicode Standard Annex #29 ([[url:http://unicode.org/reports/tr29/]])
で定義された書記素クラスタに対して繰り返します。

#@samplecode 例
"a\u0300".each_char.to_a.size # => 2
"a\u0300".each_grapheme_cluster.to_a.size # => 1
#@end

@see [[m:String#grapheme_clusters]]

--- grapheme_clusters                             -> [String]
--- grapheme_clusters {|grapheme_cluster| block } -> self

文字列の書記素クラスタの配列を返します。(self.each_grapheme_cluster.to_a と同じです)

#@samplecode 例
"a\u0300".grapheme_clusters # => ["à"]
#@end

ブロックが指定された場合は [[m:String#each_grapheme_cluster]] と同じように動作
します。ただし deprecated のため、ブロックを指定する場合は
[[m:String#each_grapheme_cluster]] を使用してください。

@see [[m:String#each_grapheme_cluster]]
--- delete_prefix(prefix) -> String
文字列の先頭から prefix を削除した文字列のコピーを返します。

@param prefix 先頭から削除する文字列を指定します。

@return 文字列の先頭から prefix を削除した文字列のコピー

#@samplecode
"hello".delete_prefix("hel") # => "lo"
"hello".delete_prefix("llo") # => "hello"
#@end

@see [[m:String#delete_prefix!]]
@see [[m:String#delete_suffix]]
@see [[m:String#start_with?]]

--- delete_prefix!(prefix) -> self | nil
self の先頭から破壊的に prefix を削除します。

@param prefix 先頭から削除する文字列を指定します。

@return 削除した場合は self、変化しなかった場合は nil

#@samplecode
"hello".delete_prefix!("hel") # => "lo"
"hello".delete_prefix!("llo") # => nil
#@end

@see [[m:String#delete_prefix]]
@see [[m:String#delete_suffix!]]
@see [[m:String#start_with?]]

--- delete_suffix(suffix) -> String
文字列の末尾から suffix を削除した文字列のコピーを返します。

@param suffix 末尾から削除する文字列を指定します。

@return 文字列の末尾から suffix を削除した文字列のコピー

#@samplecode
"hello".delete_suffix("llo") # => "he"
"hello".delete_suffix("hel") # => "hello"
#@end

@see [[m:String#chomp]]
@see [[m:String#chop]]
@see [[m:String#delete_prefix]]
@see [[m:String#delete_suffix!]]
@see [[m:String#end_with?]]

--- delete_suffix!(suffix) -> self | nil
self の末尾から破壊的に suffix を削除します。

@param suffix 末尾から削除する文字列を指定します。

@return 削除した場合は self、変化しなかった場合は nil

#@samplecode
"hello".delete_suffix!("llo") # => "he"
"hello".delete_suffix!("hel") # => nil
#@end

@see [[m:String#chomp!]]
@see [[m:String#chop!]]
@see [[m:String#delete_prefix!]]
@see [[m:String#delete_suffix]]
@see [[m:String#end_with?]]
#@end
