= class String < Object

include Comparable
include Enumerable

文字列のクラスです。
NUL 文字を含む任意のバイト列を扱うことができます。
文字列の長さにはメモリ容量以外の制限はありません。

文字列は通常、文字列リテラルを使って生成します。
以下に文字列リテラルの例をいくつか示します。

  'str\\ing'   # シングルクオート文字列 (エスケープシーケンスがほぼ無効)
  "string\n"   # ダブルクオート文字列 (エスケープシーケンスがすべて有効)
  %q(str\\ing) # 「%q」文字列 (エスケープシーケンスがほぼ無効、デリミタが変えられる)
  %Q(string\n) # 「%Q」文字列 (エスケープシーケンスがすべて有効、デリミタが変えられる)

  # ヒアドキュメント
  <<End
  この行はヒアドキュメント
  End

  # ダブルクオートヒアドキュメント (クオートなしの場合と同じ)
  <<"End"
  この行はヒアドキュメント
  End

  # シングルクオートヒアドキュメント (一切のエスケープシーケンスが無効)
  <<'End'
  この行はヒアドキュメント
  End

  # 終端記号がインデントされたヒアドキュメント
  # シングルクオート、ダブルクオートとの併用も可能
  <<-End
  この行はヒアドキュメント (終端記号をインデントできる)
     End

=== 破壊的な変更

Ruby の String クラスは mutable です。
つまり、オブジェクト自体を破壊的に変更できます。

「破壊的な変更」とは、あるオブジェクトの内容自体を変化させることです。
例えば文字列のすべての文字を破壊的に大文字へ変更する
[[m:String#upcase!]] メソッドの使用例を以下に示します。

  a = "string"
  b = a
  a.upcase!
  p a   # => "STRING"
  p b   # => "STRING"

この例では、a に対してメソッドを呼んだにも関わらず b も変更されています。
これは、変数 a と b が一つの文字列オブジェクトを指していて、
upcase! メソッドでそのオブジェクト自体が変更されたからです。

upcase! の非破壊版である [[m:String#upcase]] を使った例を以下に示します。
こちらでは a の変更が b に波及しません。

  a = "string"
  b = a
  a = a.upcase
  p a   # => "STRING"
  p b   # => "string"

一般には、破壊的「ではない」メソッドを
中心に使っていくほうがバグが出にくくなります。

String クラスのメソッドには破壊的なメソッドも非破壊的なメソッドもあります。
破壊的なメソッドの例としては concat, sub!, upcase! などが挙げられます。
非破壊的なメソッドの例としては index, sub, upcase などが挙げられます。

同じ動作で破壊的なメソッドと非破壊的なメソッドの両方が定義されているときは、
破壊的なバージョンには名前の最後に「!」が付いています。
例えば upcase メソッドは非破壊的で、upcase! メソッドは破壊的です。

ただし、この命名ルールを
「破壊的なメソッドにはすべて『!』が付いている」と解釈しないでください。
例えば concat には「!」が付いていませんが、破壊的です。あくまでも、
「『!』が付いているメソッドと付いていないメソッドの両方があるときは、
『!』が付いているほうが破壊的」というだけです。
「『!』が付いているならば破壊的」は常に成立しますが、逆は必ずしも成立しません。

=== マルチバイト文字列の処理

String クラスは自身を文字の列ではなくバイト列として扱います。
例えば str[1] は str の内容やエンコーディングに関わらず
2 バイトめの数値を返します。

マルチバイト文字列を正しく処理するためには、
原則としてインデックスよりも正規表現を使うメソッド、
例えば [[m:String#sub]] や [[m:String#gsub]] を中心に用いるべきです。
Ruby の正規表現エンジンはマルチバイト文字列に対応しているので、
正規表現を使って位置を指定すればマルチバイト文字を正しく処理できます。
なお、正規表現を正しく動作させるためには、組み込み変数 [[m:$KCODE]]
を文字列のエンコーディングにあわせて設定する必要があります。
#@# $KCODE の影響
#@#   * レクサ
#@#   * upcase, downcase, swapcase, capitalize, split, gsub, scan
#@#   * inspect ($KCODE設定されているとマルチバイト文字列をエスケープせず表示)

また、[[lib:jcode]] ライブラリを利用すると
String クラスのすべてのメソッドが文字単位で動作するようになります。
しかし jcode ライブラリはプロセス全体に影響するため、
中程度以上の規模プログラムで用いることは推奨できません。

== Class Methods

#@since 1.9.0
--- try_convert(obj) -> String | nil
#@todo

Try to convert obj into a String, using to_str method. Returns
converted regexp or nil if obj cannot be converted for any reason.

   String.try_convert("str")     # => str
   String.try_convert(/re/)      # => nil

#@end

--- new(string = "") -> String

string と同じ内容の新しい文字列を作成して返します。
引数を省略した場合は空文字列を生成して返します。

@param string	文字列
@return		引数 string と同じ内容の文字列オブジェクト

== Instance Methods

--- +(other) -> String

文字列と other を連結した新しい文字列を返します。

@param other	文字列
@return		self と other を連結した文字列

例:

  p "str" + "ing"   # => "string"

  a = "abc"
  b = "def"
  p a + b   # => "abcdef"
  p a       # => "abc"  (変化なし)
  p b       # => "def"

--- *(times) -> String

文字列の内容を times 回だけ繰り返した新しい文字列を作成して返します。

@param times	整数
@return		self を times 回繰り返した新しい文字列

例:

  p "str" * 3   # => "strstrstr"

  str = "abc"
  p str * 4   # => "abcabcabcabc"
  p str       # => "abc"  (変化なし)

--- %(args) -> String

printf と同じ規則に従って args をフォーマットします。

args が配列であれば [[m:Kernel.#sprintf]](self, *args) と同じです。
それ以外の場合は [[m:Kernel.#sprintf]](self, args) と同じです。

@param args	フォーマットする値、もしくはその配列
@return		フォーマットされた文字列

例:

  p "i = %d" % 10       # => "i = 10"
  p "i = %x" % 10       # => "i = a"
  p "i = %o" % 10       # => "i = 12"

  p "i = %#d" % 10      # => "i = 10"
  p "i = %#x" % 10      # => "i = 0xa"
  p "i = %#o" % 10      # => "i = 012"

  p "%d" % 10           # => "10"
  p "%d,%o" % [10, 10]  # => "10,12"

#@include(printf-format)

--- <=>(other) -> Integer

self と other を ASCII コード順で比較して、
self が大きい時には正の整数、等しい時には 0、小さい時には負の整数を返します。
このメソッドは Comparable モジュールのメソッドを実装するために使われます。

変数 [[m:$=]] の値が真であるときは
アルファベットの大文字小文字を無視して比較します。
ただし $= 変数はいずれ廃止されることが決まっているので
$= に頼るべきではありません。
代わりに [[m:String#casecmp]] を使ってください。

#@since 1.8.0
other が文字列でない場合、
other.to_str と other.<=> が定義されていれば
0 - (other <=> self) の結果を返します。
そうでなければ nil を返します。
#@end

@param other	文字列
@return		比較結果の整数か nil

例:

    p "aaa" <=> "xxx"   # => -1
    p "aaa" <=> "aaa"   # => 0
    p "xxx" <=> "aaa"   # => 1

    p "string" <=> "stringAA"  # => -1
    p "string" <=> "string"    # => 0
    p "stringAA" <=> "string"  # => 1

--- ==(other) -> bool

文字列の内容が文字列 other の内容と等しいときに true を返します。
等しくなければ false を返します。

このメソッドは文字列の内容を比較します。
同一のオブジェクトかどうかを比較するわけではありません。
つまり、"string" == str という式を実行した場合には、
str が "string" という内容の文字列でありさえすれば常に true を返します。
同一のオブジェクトであるかどうかを判定したいときは
[[m:Object#equal?]] を使ってください。

変数 [[m:$=]] の値が真であるときは
アルファベットの大文字小文字を無視して比較します。
ただし $= 変数はいずれ廃止されることが決まっているので
$= に頼るべきではありません。

@param other	任意のオブジェクト
@return		true か false

例:

    p "string" == "string"  # => true
    p "string" == "STRING"  # => false
    p "string" == ""        # => false
    p "" == "string"        # => false

    p "string" == "str" + "ing"   # => true   (内容が同じなら true)
    p "string" == "stringX".chop  # => true   (内容が同じなら true)

--- <<(other) -> self
--- concat(other) -> self

self に文字列 other を破壊的に連結します。
other が 0 から 255 の範囲の [[c:Fixnum]] である場合は
その 1 バイトを末尾に追加します。

self を返します。

@param other	文字列もしくは 0 から 255 までの範囲の整数

例:

    str = "string"
    str.concat "XXX"
    p str    # => "stringXXX"

--- =~(other) -> Integer

#@since 1.8.0
正規表現 other とのマッチを行います。
#@else
正規表現または文字列 other と self のマッチを実行します。
#@end
マッチが成功すればマッチした位置のインデックスを、そうでなければ nil を返します。

other が正規表現でも文字列でもない場合は
other =~ self を行います。

#@since 1.8.0
Ruby 1.6 までは、other が文字列であった場合には
other を正規表現にコンパイルして self とのマッチを実行していました。
しかし Ruby 1.8 以降では other に文字列を指定すると
例外 [[c:TypeError]] が発生します。
#@end

このメソッドが実行されると、組み込み変数 [[m:$~]], [[m:$1]], ...
にマッチに関する情報が設定されます。

#@since 1.8.0
@param other	    正規表現もしくは =~ メソッドを持つオブジェクト
@raise TypeError    other が文字列であった
#@else
@param other	    正規表現か文字列、もしくは =~ メソッドを持つオブジェクト
#@end

例:

    p "string" =~ /str/   # => 0
    p "string" =~ /not/   # => nil

#@if (version < "1.8.2")
--- ~ -> Integer

self を正規表現にコンパイルして
組み込み変数 [[m:$_]] に対してマッチを行い、
マッチした位置のインデックスを返します。
$_ =~ Regexp.compile(self) と同じです。

$_ が文字列でなければ nil を返します。

このメソッドは Ruby 1.8.2 以降は削除されます。
代わりに [[m:Regexp#~]] などを使用してください。
#@end

--- [](nth) -> Integer

nth 番目のバイトを整数 (文字コード) で返します。
nth が負の場合は文字列の末尾から数えます。
つまり、 self.size + nth 番目のバイトを返します。

nth が範囲外を指す場合は nil を返します。

@param nth	バイトインデックスを表す整数
@return         文字コードを表す整数

例:

  p 'bar'[2]        # => 114
  p 'bar'[2] == ?r  # => true
  p 'bar'[-1]       # => 114

  p 'bar'[3]        # => nil
  p 'bar'[-4]       # => nil

このメソッドの逆に文字コードから文字列を得るには
[[m:Integer#chr]] を使ってください。

--- [](nth, len) -> String

nth バイト番目から長さ len バイトの部分文字列を新しく作って返します。
nth が負の場合は文字列の末尾から数えます。

nth が範囲外を指す場合は nil を返します。

@arg nth    取得したい文字列の開始インデックス。整数
@arg len    取得したい文字列の長さ。正の整数

例:

  str0 = "bar"
  p str0[2, 1]         #=> "r"
  p str0[2, 0]         #=> ""
  p str0[2, 100]       #=> "r"  (右側を超えても平気)
  p str0[2, 1] == ?r   #=> false  (左辺は長さ1の文字列、右辺は整数の文字コード)
  p str0[-1, 1]        #=> "r"
  p str0[-1, 2]        #=> "r" (飽くまでも「右に向かって len バイト」)

  p str0[3, 1]         #=> nil
  p str0[-4, 1]        #=> nil
  str1 = str[0, 2]     # (str0の「一部」をstr1とする)
  p str1               #=> "ba"
  str1[0] = "XYZ"
  p str1               #=> "XYZa" (str1の内容が破壊的に変更された)
  p str0               #=> "bar" (str0は無傷、str1はstr0と内容を共有していない)

--- [](substr) -> String

self が substr を含む場合、一致した文字列を新しく作って返します。
substr を含まなければ nil を返します。

@arg substr    取得したい文字列のパターン。文字列

例:
    substr = "bar"
    result = "foobar"[substr]
    p result   # => "bar"
#@since 1.8.0
    p substr.equal?(result)   # => false
#@else
    p substr.equal?(result)   # => true
#@end

#@since 1.8.0
--- [](regexp, nth = 0) -> String

正規表現 regexp の nth 番目の括弧にマッチする最初の部分文字列を返します。
nth を省略したときや 0 の場合は正規表現がマッチした部分文字列全体を返します。
正規表現が self にマッチしなかった場合や nth に対応する括弧がないときは nil を返します。
#@else
--- [](regexp) -> String

self のうち regexp にマッチする最初の部分文字列を返します。
self が regexp にマッチしない場合は nil を返します。
#@end

このメソッドを実行すると、
マッチ結果に関する情報が組み込み変数 [[m:$~]] に設定されます。

@arg regexp    取得したい文字列のパターンを示す正規表現
#@since 1.8.0
@arg nth       取得したい正規表現レジスタのインデックス。整数
#@end

   p "foobar"[/bar/]  # => "bar"
   p $~.begin(0)      # => 3

   p "foobar"[/bar/]   # => "bar"
   p $~.begin(0)       # => 3

#@since 1.8.0
   p "def getcnt(line)"[ /def\s+(\w+)/, 1 ]   # => "getcnt"
#@end

--- [](first..last) -> String

インデックス first から last までのバイトを含む新しい文字列を作成して返します。
インデックスと文字列の対応については以下の対照図も参照してください。

    0   1   2   3   4   5   (インデックス)
   -6  -5  -4  -3  -2  -1   (負のインデックス)
  | a | b | c | d | e | f |
  |<--------->|                'abcdef'[0..2]  # => 'abc'
                  |<----->|    'abcdef'[4..5]  # => 'ef'
          |<--------->|        'abcdef'[2..4]  # => 'cde'

last が文字列の長さ以上のときは
(文字列の長さ - 1) を指定したものとみなされます。

first が 0 より小さいか文字列の長さより大きいとき、
および first > last + 1 であるときは nil を
返します。ただし first および last のどちらか
または両方が負の数のときは一度だけ文字列の長さを足して
再試行します。

@arg first..last   取得したい文字列の範囲を示す Range オブジェクト

例:

  'abcd'[ 2 ..  1] # => ""
  'abcd'[ 2 ..  2] # => "c"
  'abcd'[ 2 ..  3] # => "cd"
  'abcd'[ 2 ..  4] # => "cd"

  'abcd'[ 2 .. -1] # => "cd"   # str[f..-1] は「f 文字目から
  'abcd'[ 3 .. -1] # => "d"    # 文字列の最後まで」を表す慣用句

  'abcd'[ 1 ..  2] # => "bc"
  'abcd'[ 2 ..  2] # =>  "c"
  'abcd'[ 3 ..  2] # =>   ""
  'abcd'[ 4 ..  2] # =>  nil

  'abcd'[-3 ..  2] # =>  "bc"
  'abcd'[-4 ..  2] # => "abc"
  'abcd'[-5 ..  2] # =>  nil

--- [](first...last) -> String

文字列先頭を 0 番目の隙間、末尾を self.length 番目の隙間として、
first 番目の隙間から last 番目の隙間までに含まれる
バイト列を含んだ新しい文字列を作成して返します。

文字列と「隙間」の関係については以下の模式図を参照してください。

     0   1   2   3   4   5   6  (隙間番号)
    -6  -5  -4  -3  -2  -1      (負の隙間番号)
     | a | b | c | d | e | f |
     |<--------->|                'abcdef'[0...3]  # => 'abc'
                     |<----->|    'abcdef'[4...6]  # => 'ef'
             |<--------->|        'abcdef'[2...5]  # => 'cde'

last が文字列の長さよりも大きいときは文字列の長さを
指定したものとみなされます。

first が 0 より小さいか文字列の長さより大きいとき、
および first > last であるときは nil を返します。
ただし first と last のどちらかまたは両方が負の数
であるときは一度だけ文字列の長さを足して再試行します。

@arg first...last   取得したい文字列の範囲を示す Range オブジェクト

例:
    'abcd'[ 2 ... 3] # => "c"
    'abcd'[ 2 ... 4] # => "cd"
    'abcd'[ 2 ... 5] # => "cd"

    'abcd'[ 1 ... 2] # => "b"
    'abcd'[ 2 ... 2] # => ""
    'abcd'[ 3 ... 2] # => nil

    'abcd'[-3 ... 2] # => "b"
    'abcd'[-4 ... 2] # => "ab"
    'abcd'[-5 ... 2] # => nil

--- []=(nth, val) -> val

nth 番目のバイトを文字列 val で置き換えます。
val が 0 から 255 の範囲の整数である場合、
文字コードとみなしてその文字で置き換えます。

val を返します。

@arg nth    置き換えたいバイトのインデックス
@arg val    指定バイトと置き換える文字列もしくはバイト

例:

    buf = "string"
    buf[1] = "!!"
    p buf   # => "s!!ring"

--- []=(nth, len, val) -> val

nth バイト番目から長さ len バイトの部分文字列を文字列 val で置き換えます。
nth が負の場合は文字列の末尾から数えます。

val を返します。

@arg nth    置き換えたい部分文字列の開始インデックス
@arg len    置き換えたい部分文字列の長さ
@arg val    指定範囲の部分文字列と置き換える文字列

例:

    buf = "string"
    buf[1, 4] = "!!"
    p buf   # => "s!!g"

--- []=(substr, val) -> val

文字列中の substr に一致する最初の部分文字列を文字列 val で置き換えます。

self が substr を含まない場合は
例外 [[c:IndexError]] が発生します。

val を返します。

@arg substr    置き換えたい部分文字列のパターンを示す文字列
@arg val       指定範囲の部分文字列と置き換える文字列

@raise IndexError    self が部分文字列 substr を含まない

例:
     buf = "string"
     buf["trin"] = "!!"
     p buf   # => "s!!g"

     buf = "string"
     buf["nosuchstring"] = "!!"   # IndexError

#@since 1.8.0
--- []=(regexp, nth = 0, val) -> ()

正規表現 regexp の nth 番目の括弧にマッチする
最初の部分文字列を文字列 val で置き換えます。
nth を省略したときや nth が 0 の場合は、
マッチした部分文字列全体を val で置き換えます。

正規表現がマッチしなければ例外 [[c:IndexError]] が発生します。
#@else
--- []=(regexp, val) -> ()

正規表現 regexp にマッチする最初の部分文字列を文字列 val で置き換えます。

正規表現がマッチしない場合や
nth に対応する括弧がないときは例外 [[c:IndexError]] が発生します。
#@end

val を返します。

@arg regexp    置き換えたい部分文字列のパターンを示す正規表現
#@since 1.8.0
@arg nth       置き換えたい部分文字列のパターンを示す正規表現レジスタの番号
#@end
@arg val       指定範囲の部分文字列と置き換えたい文字列

例:
    buf = "string"
    buf[/tr../] = "!!"
    p buf   # => "s!!g"

#@since 1.8.0
    buf = "def exec(cmd)"
    buf[/def\s+(\w+)/, 1] = "preprocess"
    p buf    # => "def preprocess(cmd)"
#@end

--- []=(first..last, val) -> val

インデックス first から last までの部分文字列を文字列 val で置き換えます。

val を返します。

@arg first..last   置き換えたい範囲を示す [[c:Range]] オブジェクト

--- []=(first...last, val) -> val

インデックス first から last までの部分文字列を文字列 val で置き換えます。

val を返します。

@arg firstl...last   置き換えたい範囲を示す [[c:Range]] オブジェクト

--- capitalize -> String

文字列先頭の文字を大文字に、残りを小文字に変更した文字列を返します。
ただし、アルファベット以外の文字は位置に関わらず変更しません。

例:

  p "foobar--".capitalize   # => "Foobar--"
  p "fooBAR--".capitalize   # => "Foobar--"
  p "FOOBAR--".capitalize   # => "Foobar--"

[[m:$KCODE]] が適切に設定されていない場合は、
マルチバイト文字の一部をあやまって変換してしまう場合があります。
この問題は以下のように Shift JIS エンコーディングを使う場合に発生します。

  $KCODE = 'NONE'
  # 文字列は Shift JIS エンコーディングで記述されている
  puts "帰".capitalize   # => 蟻

また、$KCODE を設定しても、
マルチバイト文字のいわゆる全角アルファベットは処理しません。

@see [[m:String#capitalize!]], [[m:String#upcase]],
     [[m:String#downcase]], [[m:String#swapcase]]

--- capitalize! -> ()

文字列先頭の文字を大文字に、残りを小文字に変更します。
ただし、アルファベット以外の文字は位置に関わらず変更しません。

capitalize! は self を変更して返しますが、
変更が起こらなかった場合は nil を返します。

例:

  str = "foobar"
  str.capitalize!
  p str   # => "Foobar"

  str = "fooBAR"
  str.capitalize!
  p str   # => "Foobar"

[[m:$KCODE]] が適切に設定されていない場合は、
マルチバイト文字の一部をあやまって変換してしまう場合があります。
この問題は以下のように Shift JIS エンコーディングを使う場合に発生します。

  $KCODE = 'NONE'
  # 文字列は Shift JIS エンコーディングで記述されている
  puts "帰".capitalize   # => 蟻

また、$KCODE を設定しても、
マルチバイト文字のいわゆる全角アルファベットは処理しません。

@see [[m:String#capitalize]], [[m:String#upcase]],
     [[m:String#downcase]], [[m:String#swapcase]]

--- casecmp(other) -> Integer

[[m:String#<=>]] と同様に文字列の順序を比較しますが、
アルファベットの大文字小文字の違いを無視します。

このメソッドの動作は組み込み変数 [[m:$=]] には影響されません。

@arg other    self と比較する文字列

例:

  p 'a' <=> 'A'       # => 1
  p 'a'.casecmp('A')  # => 0

@see [[m:String#<=>]]

#@since 1.8.0
--- center(width, padding = ' ') -> String
#@else
--- center(width) -> String
#@end

長さ width の文字列に self を中央寄せした文字列を返します。
self の長さが width より長い時には元の文字列の複製を返します。
#@since 1.8.0
また、第 2 引数 padding を指定したときは
空白文字の代わりに padding を詰めます。
#@end

@arg width      返り値の文字列の最小の長さ
#@since 1.8.0
@arg padding    長さが width になるまで self の両側に詰める文字
#@end

例:

  p "foo".center(10)       # => "   foo    "
  p "foo".center(9)        # => "   foo   "
  p "foo".center(8)        # => "  foo   "
  p "foo".center(7)        # => "  foo  "
  p "foo".center(3)        # => "foo"
  p "foo".center(2)        # => "foo"
  p "foo".center(1)        # => "foo"
#@since 1.8.0
  p "foo".center(10, "*")  # => "***foo****"
#@end

@see [[m:String#ljust]], [[m:String#rjust]]

#@since 1.8.0
--- ljust(width, padding = ' ') -> String
#@else
--- ljust(width) -> String
#@end

長さ width の文字列に self を左詰めした文字列を返します。
self の長さが width より長い時には元の文字列の複製を返します。
#@since 1.8.0
また、第 2 引数 padding を指定したときは
空白文字の代わりに padding を詰めます。
#@end

@arg width      返り値の文字列の最小の長さ
#@since 1.8.0
@arg padding    長さが width になるまで self の右側に詰める文字
#@end

例:

  p "foo".ljust(10)        # => "foo       "
  p "foo".ljust(9)         # => "foo      "
  p "foo".ljust(8)         # => "foo     "
  p "foo".ljust(2)         # => "foo"
  p "foo".ljust(1)         # => "foo"
#@since 1.8.0
  p "foo".ljust(10, "*")   # => "foo*******"
#@end

@see [[m:String#center]], [[m:String#rjust]]

#@since 1.8.0
--- rjust(width, padding = ' ') -> String
#@else
--- rjust(width) -> String
#@end

長さ width の文字列に self を右詰めした文字列を返します。
self の長さが width より長い時には元の文字列の複製を返します。
#@since 1.8.0
また、第 2 引数 padding を指定したときは
空白文字の代わりに padding を詰めます。
#@end

@arg width      返り値の文字列の最小の長さ
#@since 1.8.0
@arg padding    長さが width になるまで self の右側に詰める文字
#@end

例:

  p "foo".rjust(10)        # => "       foo"
  p "foo".rjust(9)         # => "      foo"
  p "foo".rjust(8)         # => "     foo"
  p "foo".rjust(2)         # => "foo"
  p "foo".rjust(1)         # => "foo"
#@since 1.8.0
  p "foo".rjust(10, "*")   # => "*******foo"
#@end

@see [[m:String#center]], [[m:String#ljust]]

--- chomp(rs = $/) -> String

self の末尾から rs で指定する改行コードを取り除いた文字列を生成し返します。
#@since 1.8.0
ただし、rs が "\n" ($/ のデフォルト値) のときは、
実行環境によらず "\r", "\r\n", "\n" のすべてを改行コードとみなして取り除きます。
#@end

rs に nil を指定した場合、このメソッドは何もしません。

rs に空文字列 ("") を指定した場合は「パラグラフモード」になり、
末尾の連続する改行コードをすべて取り除きます。


例:

  p "foo\n".chomp             # => "foo"
  p "foo\n".chomp("\n")       # => "foo"
  p "foo\r\n".chomp("\r\n")   # => "foo"

#@since 1.8.0
  $/ = "\n"   # デフォルト値と同じ
  p "foo\r".chomp    # => "foo"
  p "foo\r\n".chomp  # => "foo"
  p "foo\n".chomp    # => "foo"
  p "foo\n\r".chomp  # => "foo\n"
#@end

--- chomp!(rs = $/) -> ()

self の末尾から rs で指定する改行コードを取り除きます。
#@since 1.8.0
ただし rs が "\n" ($/ のデフォルト値) のときは、
システムによらず "\r", "\r\n", "\n" のすべてを改行コードとみなして取り除きます。
#@end

rs に nil を指定した場合、このメソッドは何もしません。

rs に空文字列 ("") を指定した場合は「パラグラフモード」になり、
末尾の連続する改行コードをすべて取り除きます。

chomp! は通常 self を返しますが、
取り除く改行がなかった場合は nil を返します。

例:

  buf = "string\n"
  buf.chomp!
  p buf   # => "string"

#@since 1.8.0
  $/ = "\n"   # デフォルトと同じ
  p "foo\r".chomp    # => "foo"
  p "foo\r\n".chomp  # => "foo"
  p "foo\n".chomp    # => "foo"
  p "foo\n\r".chomp  # => "foo\n"
#@end

--- chop -> String

文字列の最後の文字を取り除いた新しい文字列を生成して返します。
ただし、文字列の終端が "\r\n" であればその 2 文字を取り除きます。

例:
    p "string\n".chop    # => "string"
    p "string\r\n".chop  # => "string"
    p "string".chop      # => "strin"
    p "strin".chop       # => "stri"
    p "".chop            # => ""

--- chop! -> ()

文字列の最後の文字を取り除きます。
ただし、終端が "\r\n" であればその 2 文字を取り除きます。

chop! は self を変更して返しますが、
取り除く文字がなかった場合は nil を返します。

#@since 1.9.0
--- clear -> ()

文字列の内容を削除して空にします。
self を返します。

例:
    str = "abc"
    str.clear
    p str     # => ""

    str = ""
    str.clear
    p str   # => ""
#@end

#@#--- clone
#@#--- dup
#@#
#@#文字列と同じ内容を持つ新しい文字列を返します。
#@#フリーズ [[m:Object#freeze]] した文字列の
#@#clone はフリーズされた文字列を返しますが、
#@#dup は内容の等しいフリーズされていない文字列を返します。
#@#すなわち dup と [[m:String#new]] は等価です。
#@#
#@# [[m:Object#clone]],[[m:Object#dup]]を参照するべき

--- count(*chars) -> Integer

chars で指定された文字が文字列 self にいくつあるか数えます。

検索する文字を示す引数 chars の形式は [[man:tr(1)]] と同じです。
つまり、「"a-c"」は文字 a から c を意味し、
「"^0-9"」のように文字列の先頭が「^」の場合は
指定文字以外を意味します。

文字「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、「^」も文字列の先頭にあるときだけ否定の効果を発揮します。
また、「-」「^」「\」は
バックスラッシュ (「\」) によりエスケープできます。

引数を複数指定した場合は、
すべての引数にマッチした文字だけを数えます。

@arg chars    出現回数を数える文字のパターン

例:

  p 'abcdefg'.count('c')               # => 1
  p '123456789'.count('2378')          # => 4
  p '123456789'.count('2-8', '^4-6')   # => 4

  # ファイルの行数を数える
  n_lines = File.open("foo").read.count("\n")

  # ファイルの末尾に改行コードがない場合にも対処する
  buf = File.open("foo").read
  n_lines = buf.count("\n")
  n_lines += 1 if /[^\n]\z/ =~ buf
      # if /\n\z/ !~ buf だと空ファイルを 1 行として数えてしまうのでダメ

--- crypt(salt) -> String

self と salt から暗号化された文字列を生成して返します。
salt には英数字、ドット (「.」)、スラッシュ (「/」) から構成される、
2 バイト以上の文字列を指定します。

暗号化された文字列から暗号化前の文字列 (self) を求めることは一般に困難で、
self を知っている者のみが同じ暗号化された文字列を生成できます。
このことから self を知っているかどうかの認証に使うことが出来ます。

salt には、以下の様になるべくランダムな文字列を選ぶべきです。
他にも [[ruby-list:29297]] などがあります。

注意:

  * crypt の処理は [[man:crypt(3)]] の実装に依存しています。
    従って、crypt で処理される内容の詳細や salt の与え方については、
    利用環境の [[man:crypt(3)]] 等を見て確認してください。
  * crypt の結果は利用環境が異なると変わる場合があります。
    crypt の結果を、異なる利用環境間で使用する場合には注意して下さい。
  * 典型的な DES を使用した [[man:crypt(3)]] の場合、
    self の最初の 8 バイト、salt の最初の 2 バイトだけが使用されます。

@arg salt    文字列を暗号化するための鍵となる文字列。
             英数字・「.」・「/」のいずれかで構成される 2 バイト以上の文字列

例:
    # パスワードの暗号化
    salt = [rand(64),rand(64)].pack("C*").tr("\x00-\x3f","A-Za-z0-9./")
    passwd.crypt(salt)

    # UNIX のログイン認証
    require 'etc'

    def valid_login?(user, password)
      ent = Etc.getpwnam(user)
      passwd.crypt(ent.passwd) == ent.passwd
    end

    p valid_login?("taro", "password")   # => 真偽値が得られる

--- delete(*strs) -> String

self から strs に含まれる文字を取り除いた文字列を生成し返します。

str の形式は [[man:tr(1)]] と同じです。
つまり、`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外を意味します。

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
「^」も文字列の先頭にあるときだけ効果を発揮します。
また、「-」「^」「\」はバックスラッシュ (「\」)
によってエスケープできます。

なお、引数を複数指定した場合は、
すべての引数にマッチする文字だけが削除されます。

@arg strs    削除する文字列を示す文字列 (のリスト)

例:
    p "123456789".delete("2378")         #=> "14569"
    p "123456789".delete("2-8", "^4-6")  #=> "14569"

--- delete!(*strs) -> ()

self から strs に含まれる文字を破壊的に取り除きます。

str の形式は [[man:tr(1)]] と同じです。
つまり、「a-c」は a から c を意味し、"^0-9" のように
文字列の先頭が「^」の場合は指定文字以外を意味します。

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
「^」も文字列先頭にあるときだけ否定の効果を発揮します。
また、「-」「^」「\」はバックスラッシュ (「\」)
によってエスケープできます。

なお、引数を複数指定した場合は、
すべての引数にマッチする文字だけが削除されます。

通常は self を返しますが、
何も変更が起こらなかった場合は nil を返します。

@arg strs    削除する文字列を示す文字列 (のリスト)

例:

  p "123456789".delete("2-8", "^4-6")  #=> "14569"
  p "123456789".delete("2378")         #=> "14569"

--- downcase -> String

アルファベット大文字をすべて小文字に置き換えた新しい文字列を生成し返します。
アルファベット大文字以外の文字はすべてそのまま保存されます。

処理する文字列の文字コードが Shift JIS で、
しかも [[m:$KCODE]] が適切に設定されていない場合、
このメソッドはマルチバイト文字の一部も変換してしまう場合があります。
逆に、[[m:$KCODE]] を適切に設定しても
マルチバイト文字のアルファベットは処理できません。

例:
    p "STRing?".downcase   # => "string?"

    # -*- Coding: shift_jis -*-
    $KCODE ='n'
    puts "帰".downcase   # => 蟻
  
@see [[m:String#upcase]], [[m:String#swapcase]], [[m:String#capitalize]]

--- downcase! -> ()

文字列中のアルファベット大文字をすべて破壊的に小文字に置き換えます。
アルファベット大文字以外の文字はすべてそのまま保存されます。

処理する文字列の文字コードが Shift JIS で、
しかも [[m:$KCODE]] が適切に設定されていない場合、
このメソッドはマルチバイト文字の一部も変換してしまう場合があります。
逆に、[[m:$KCODE]] を適切に設定しても
マルチバイト文字のアルファベットは処理できません。

例:
    p "STRing?".downcase   # => "string?"

    # -*- Coding: shift_jis -*-
    $KCODE ='n'
    puts "帰".downcase   # => 蟻
  
@see [[m:String#upcase]], [[m:String#swapcase]], [[m:String#capitalize]]

--- dump -> String

文字列中の非表示文字をバックスラッシュ記法に置き換えた文字列を返します。
str == eval(str.dump) となることが保証されています。

例:
    # p だとさらにバックスラッシュが増えて見にくいので puts している
    puts "abc\r\n\f\x00\b10\\\"".dump   # => "abc\r\n\f\000\01010\\\""

--- each(rs = $/) {|line| ... } -> ()
--- each_line(rs = $ /) {|line| ... } -> ()

文字列中の各行に対して繰り返します。
行の区切りは rs に指定した文字列で、
そのデフォルト値は変数 [[m:$/]] の値です。
各 line には区切りの文字列も含みます。

rs に nil を指定すると行区切りなしとみなします。
rs に空文字列 "" を指定すると「パラグラフモード」になり、
改行コードが 2 つ以上連続するところで文字列を分割します
(つまり空行で分割します)。

@arg rs    行末を示す文字列

例:
    "aa\nbb\ncc\n".each do |line|
      p line
    end
        # => "aa\n"
        # => "bb\n"
        # => "cc\n"

--- each_byte {|byte| ... } -> ()

文字列の各バイトに対して繰り返します。

なお、バイトごとに分割した配列を得たいときは、
Ruby 1.8 までなら unpack('C*') を、
Ruby 1.9 以降は String#bytes を使ってください。

例:
    "str".each do |byte|
      p byte
    end
        # => 115
        # => 116
        # => 114

#@since 1.9.0
@see [[m:String#bytes]]
#@else
@see [[m:String#unpack]]
#@end

#@since 1.9.0
--- bytes -> Enumerable::Enumerator

文字列をバイト配列 (を表す Enumerator) に分割します。

例:
    p "string".bytes   # => [115, 116, 114, 105, 110, 103]
#@end

--- empty? -> bool

文字列が空 (つまり長さ 0) の時、真を返します。

--- gsub(pattern, replace) -> String

文字列中で pattern にマッチする部分全てを
文字列 replace で置き換えた文字列を生成し返します。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

@arg pattern    置き換える文字列のパターン
@arg replace    pattern で指定した文字列と置き換える文字列

例:
    p 'abcdefg'.gsub(/def/, '!!')          # => "abc!!g"
    p 'abcabc'.gsub(/b/, '<<\&>>')         # => "a<<b>>ca<<b>>c"
    p 'xxbbxbb'.gsub(/x+(b+)/, 'X<<\1>>')  # => "X<<bb>>X<<bb>>"

注意:

第 2 引数 replace に [[m:$1]] を埋め込んでも意図した結果にはなりません。
この文字列が評価される時点ではまだ正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、gsub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

    # ひとつめの括弧の内容に置き換えるときによくある間違い
    p 'xbbb-xbbb'.gsub(/x(b+)/, "#{$1}")   # => "-"        # NG
    p 'xbbb-xbbb'.gsub(/x(b+)/, "\1")      # => "1-1"      # NG
    p 'xbbb-xbbb'.gsub(/x(b+)/, "\\1")     # => "bbb-bbb"  # OK
    p 'xbbb-xbbb'.gsub(/x(b+)/, '\1')      # => "bbb-bbb"  # OK
    p 'xbbb-xbbb'.gsub(/x(b+)/, '\\1')     # => "bbb-bbb"  # OK

    # バックスラッシュを倍にするときによくある間違い
    puts '\n'.gsub(/\\/, "\\\\")      # => \n   # NG
    puts '\n'.gsub(/\\/, '\\\\')      # => \n   # NG
    puts '\n'.gsub(/\\/, "\\\\\\\\")  # => \\n  # OK
    puts '\n'.gsub(/\\/, '\\\\\\\\')  # => \\n  # OK

このような間違いを確実に防止し、コードの可読性を上げるには、
\& や \1 よりも下記のようにブロック付き形式の gsub を使うべきです。

    p 'xbbb-xbbb'.gsub(/x(b+)/) { $1 }   # => "bbb-bbb"  # OK

    puts '\n'.gsub(/\\/) { '\\\\' }      # => \\n        # OK

@see [[m:String#sub]]

--- gsub(pattern) {|matched| .... } -> String

文字列中で pattern にマッチした部分を順番にブロックに渡し、
その実行結果で置き換えます。
ブロックなしの場合と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

@arg pattern    置き換える文字列のパターン

例:

    p 'abcabc'.gsub(/b/) {|s| s.upcase }  #=> "aBcaBc"
    p 'abcabc'.gsub(/b/) { $&.upcase }    #=> "aBcaBc"

@see [[m:String#sub]]

--- gsub!(pattern, replace) -> ()

文字列中で pattern にマッチする部分全てを文字列 replace に破壊的に置き換えます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

gsub! は通常 self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@arg pattern    置き換える文字列のパターン
@arg replace    pattern で指定した文字列と置き換える文字列

例:

    buf = "String-String"
    buf.gsub!(/in./, "!!")
    p buf   # => "Str!!-Str!!"

    buf = "String.String"
    buf.gsub!(/in./, '<<\&>>')
    p buf   # => "Str<<ing>>-Str<<ing>>"

注意:

引数 replace の中で [[m:$1]] を使うことはできません。
replace は gsub メソッドの呼び出しより先に評価されるので、
まだ gsub の正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、gsub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

例:
    # ひとつめの括弧にマッチした部分に置き換えるときによくやる間違い
    'abbbcd'.gsub!(/a(b+)/, "#{$1}")       # NG
    'abbbcd'.gsub!(/a(b+)/, "\1")          # NG
    'abbbcd'.gsub!(/a(b+)/, "\\1")         # OK
    'abbbcd'.gsub!(/a(b+)/, '\\1')         # OK
    'abbbcd'.gsub!(/a(b+)/, '\1')          # OK
    'abbbcd'.gsub!(/a(b+)/) { $1 }         # OK   これがもっとも安全

@see [[m:String#sub]]

--- gsub!(pattern) {|matched| .... } -> ()

文字列中で pattern にマッチする部分全てを順番にブロックに渡し、
その評価結果に置き換えます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

また、ブロックなしの場合と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@arg pattern    置き換える文字列のパターン

例:
    str = 'abcabc'
    str.gsub!(/b/) {|s| s.upcase }
    p str    #=> "aBcaBc"

    str = 'abcabc'
    str.gsub!(/b/) { $&.upcase }
    p str    #=> "aBcaBc"

@see [[m:String#sub]]

--- hex -> Integer

文字列に 16 進数で数値が表現されていると解釈して整数に変換します。
接頭辞 "0x", "0X" とアンダースコアは無視されます。
文字列が [_0-9a-fA-F] 以外の文字を含むときはその文字以降を無視します。

self が空文字列のときは 0 を返します。

例:
    p "10".hex    # => 16
    p "ff".hex    # => 255
    p "0x10".hex  # => 16
    p "-0x10".hex # => -16

    p "xyz".hex   # => 0
    p "10z".hex   # => 16
    p "1_0".hex   # => 16

    p "".hex      # => 0

@see [[m:String#oct]], [[m:String#to_i]], [[m:String#to_f]],
     [[m:Kernel.#Integer]], [[m:Kernel.#Float]]

このメソッドの逆に数値を文字列に変換するには
[[m:Kernel.#sprintf]], [[m:String#%]],
[[m:Integer#to_s]]
などを使ってください。

--- include?(substr) -> bool

文字列中に部分文字列 substr が含まれていれば真を返します。

substr が 0 から 255 の範囲の [[c:Fixnum]] の場合、
文字コードとみなして、その文字が含まれていれば真を返します。

@arg substr    検索する文字列もしくは文字コードを表す整数

--- index(pattern, pos = 0) -> Integer

インデックス pos から右に向かって pattern を検索し、
最初に見つかった部分文字列の左端のインデックスを返します。
見つからなければ nil を返します。

引数 pattern は探索する部分文字列、
正規表現、文字コードを示す 0 から 255 の整数のいずれかで指定します。

pos が負の場合、文字列の末尾から数えた位置から探索します。

@arg pattern    探索する部分文字列、正規表現、文字コードを示す 0 から 255 の整数
@arg pos        探索を開始するインデックス
  
例:

  p "astrochemistry".index("str")         # => 1
  p "regexpindex".index(/e.*x/, 2)        # => 3
  p "character".index(?c)                 # => 0

  p "foobarfoobar".index("bar", 6)        # => 9
  p "foobarfoobar".index("bar", -6)       # => 9

@see [[m:String#rindex]]

#@since 1.8.0
--- insert(pos, other) -> ()

nth 番目の文字の直前に文字列 other を挿入します。
self[pos, 0] = other と同じ操作です。

@arg pos      文字列を挿入するインデックス
@arg other    挿入する文字列

例:
    str = "foobaz"
    str.insert(3, "bar")
    p str   # => "foobarbaz"
#@end

--- intern -> Symbol
#@since 1.8.0
--- to_sym -> Symbol
#@end

文字列に対応するシンボル値 [[c:Symbol]] を返します。
ナルキャラクタ ("\0") を含む文字列を intern すると
例外 [[c:ArgumentError]] が発生します。

なお、このメソッドの逆にシンボルに対応する文字列を得るには
[[m:Symbol#to_s]] または [[m:Symbol#id2name]] を使います。

@raise ArgumentError    self が "\0" を含む

例:
    p "foo".intern                 # => :foo
    p "foo".intern.to_s == "foo"   # => true

--- length -> Integer
--- size -> Integer

文字列のバイト数を返します。

#@if (version >= "1.8.0")
#@since 1.9.0
--- match(regexp, pos = 0) -> MatchData

regexp.match(self, pos) と同じです。
#@else
--- match(regexp) -> MatchData

regexp.match(self) と同じです。
#@end
regexp が文字列の場合は、正規表現にコンパイルします。
詳しくは [[m:Regexp#match]] を参照してください。
#@end

--- succ -> String
--- next -> String

self の「次の」文字列を返します。
「次の」文字列は、アルファベットなら 16 進数、
数字なら 10 進数とみなして計算されます。
「次の」文字列の計算では "99" → "100" のように繰り上げも行われます。
このとき負符号などは考慮されません。

self にアルファベットや数字とそれ以外の文字が混在している場合、
アルファベットと数字だけが「次の」文字になり、残りは保存されます。
逆に self がアルファベットや数字をまったく含まない場合は、
単純に文字コードを 1 増やします。

さらに、self が空文字列の場合は "" を返します。

このメソッドはマルチバイト文字を意識せず、
単に文字列をバイト列として扱います。

なお、succ と逆の動作をするメソッドはありません。

例:
    p "aa".succ   # => "ab"

    # 繰り上がり
    p "99".succ   # => "100"
    p "a9".succ   # => "b0"
    p "Az".succ   # => "Ba"
    p "zz".succ   # => "aaa"
    p "-9".succ   # => "-10"
    p "9".succ    # => "10"
    p "09".succ   # => "10"

    # アルファベット・数字とそれ以外の混在
    p "1.9.9".succ # => # "2.0.0"

    # アルファベット・数字以外のみ
    p ".".succ     # => "/"
    p "\0".succ    # => "\001"
    p "\377".succ  # => "\001\000"

このメソッドは文字列の [[c:Range]] の内部で使用されます。

--- succ! -> ()
--- next! -> ()

self を「次の」文字列に置き換えます。
「次の」文字列は、アルファベットなら 16 進数、
数字なら 10 進数とみなして計算されます。
「次の」文字列の計算では "99" → "100" のように繰り上げも行われます。
このとき負符号などは考慮されません。

self にアルファベットや数字とそれ以外の文字が混在している場合、
アルファベットと数字だけが「次の」文字になり、残りは保存されます。
逆に self がアルファベットや数字をまったく含まない場合は、
単純に文字コードを 1 増やします。

さらに、self が空文字列の場合は "" を返します。

このメソッドはマルチバイト文字を意識せず、
単に文字列をバイト列として扱います。

なお、succ! と逆の動作をするメソッドはありません。

例:
    p "aa".succ   # => "ab"

    # 繰り上がり
    p "99".succ   # => "100"
    p "a9".succ   # => "b0"
    p "Az".succ   # => "Ba"
    p "zz".succ   # => "aaa"
    p "-9".succ   # => "-10"
    p "9".succ    # => "10"
    p "09".succ   # => "10"

    # アルファベット・数字とそれ以外の混在
    p "1.9.9".succ # => # "2.0.0"

    # アルファベット・数字以外のみ
    p ".".succ     # => "/"
    p "\0".succ    # => "\001"
    p "\377".succ  # => "\001\000"

@see [[m:String#succ]]

--- oct -> Integer

文字列を 8 進文字列であると解釈して、整数に変換します。

例:

  p "10".oct  # => 8
  p "010".oct # => 8
  p "8".oct   # => 0

oct は文字列の接頭辞 ("0", "0b", "0B", "0x", "0X") に応じて
8 進以外の変換も行います。

例:

  p "0b10".oct  # => 2
  p "10".oct    # => 8
  p "010".oct   # => 8
  p "0x10".oct  # => 16

整数とみなせない文字があればそこまでを変換対象とします。
変換対象が空文字列であれば 0 を返します。

#@since 1.8.0
Ruby 1.6 では、8 進だけが符号を許す。
Ruby 1.8 以降はいずれも符号を許す

例:

  p "-010".oct     # => -8
  p "-0x10".oct    # => 0
  p "-0b10".oct    # => 0

  p "1_0_1x".oct   # => 65
#@end

@see [[m:String#hex]], [[m:String#to_i]], [[m:String#to_f]],
     [[m:Kernel.#Integer]], [[m:Kernel.#Float]]

逆に、数値を文字列に変換するには[[m:Kernel.#sprintf]],
[[m:String#%]], [[m:Integer#to_s]] を使用します。

--- replace(other) -> ()

self の内容を other の内容で置き換えます。

例:
    str = "foo"
    str.replace "bar"
    p str   # => "bar"

--- reverse -> String

文字列をバイト単位で左右逆転した文字列を返します。

例:
    p "foobar".reverse   # => "raboof"
    p "".reverse         # => ""

--- reverse! -> ()

文字列をバイト単位で左右逆転します。

例:
    str = "foobar"
    str.reverse!
    p str   # => "raboof"

--- rindex(pattern, pos = self.size) -> Integer | nil

文字列のインデックス pos から左に向かって pattern を探索します。
見つかった部分文字列の左端のインデックスを返します。
見つからなければ nil を返します。

pos が負の場合は、文字列の末尾から数えた位置から探索します。

rindex と [[m:String#index]] とでは、探索方向だけが逆になります。
完全に左右が反転した動作をするわけではありません。
探索はその開始位置を右から左にずらしながら行いますが、
部分文字列の照合はどちらのメソッドも左から右に向かって行います。
以下の例を参照してください。

    # String#index の場合
    p "stringstring".index("ing", 1)    # => 3
      # ing            # ここから探索を始める
      #  ing
      #   ing          # 右にずらしていってここで見つかる

    # String#rindex の場合
    p "stringstring".rindex("ing", -1)  # => 9
      #           ing    # インデックス -1 のバイトから探索を始める
      #          ing
      #         ing      # 左にずらしていってここで見つかる

@param pattern   探索する部分文字列。
                 文字列、正規表現、文字コードを示す 0 から 255 の整数のいずれか
@param pos       探索を始めるインデックス

例:
    p "astrochemistry".rindex("str")        # => 10
    p "character".rindex(?c)                # => 5
    p "regexprindex".rindex(/e.*x/, 2)      # => 1

    p "foobarfoobar".rindex("bar", 6)       # => 3
    p "foobarfoobar".rindex("bar", -6)      # => 3

@see [[m:String#index]]

--- scan(re) -> [String] | [[String]]

self に対して正規表現 re を繰り返しマッチし、
マッチした部分文字列の配列を返します。

正規表現が括弧を含む場合は、
括弧で括られたパターンにマッチした部分文字列の配列の配列を返します。

例:
    p "foobar".scan(/../)               # => ["fo", "ob", "ar"]
    p "foobarbazfoobarbaz".scan(/ba./)  # => ["bar", "baz", "bar", "baz"]

    p "foobar".scan(/(.)/)
        # => [["f"], ["o"], ["o"], ["b"], ["a"], ["r"]]

    p "foobarbazfoobarbaz".scan(/(ba)(.)/)
        # => [["ba", "r"], ["ba", "z"], ["ba", "r"], ["ba", "z"]]

--- scan(re) {|s| ... } -> ()

正規表現 re がマッチした部分文字列をブロックに渡して実行します。
正規表現 re が括弧を含む場合は、
括弧で括られたパターンにマッチした文字列の配列を渡します。

#@since 1.8.0
Ruby 1.6 以前は re が文字列の場合、
その文字列を正規表現にコンパイルしていました。
Ruby 1.8 以降は、その文字列そのものがパターンになります。
#@end

例:
    "foobarbazfoobarbaz".scan(/ba./) {|s| p s }
        # => "bar"
        #    "baz"
        #    "baz"
        #    "baz"

    "foobarbazfoobarbaz".scan(/(ba)(.)/) {|s| p s }
        # => ["ba", "r"]
        #    ["ba", "z"]
        #    ["ba", "r"]
        #    ["ba", "z"]

--- slice(nth) -> Integer
--- slice(pos, len) -> String
--- slice(substr) -> String
#@since 1.8.0
--- slice(regexp, nth = 0) -> String
#@else
--- slice(regexp) -> String
#@end
--- slice(first..last) -> String
--- slice(first...last) -> String

[[m:String#[] ]] と同じです。

--- slice!(nth) -> Integer
--- slice!(pos, len) -> String
--- slice!(substr) -> String
#@since 1.8.0
--- slice!(regexp, nth = 0) -> String
#@else
--- slice!(regexp) -> String
#@end
--- slice!(first..last) -> String
--- slice!(first...last) -> String
--- slice!(regexp, nth = 0) -> String

指定した範囲 ([[m:String#[] ]] 参照) を
文字列から取り除いたうえで取り除いた部分文字列を返します。

引数が範囲外を指す場合は nil を返します。

--- split(sep = $/, limit = 0) -> [String] | [[String]]

第 1 引数 sep で指定されたセパレータによって文字列を limit 個まで分割し、
結果を文字列の配列で返します。

第 1 引数 sep は以下のいずれかです。

: 正規表現
    正規表現にマッチする部分で分割する。
    特に、括弧によるグルーピングがあればそのグループにマッチした
    文字列も結果の配列に含まれる (後述)。
#@since 1.8.0
: 文字列
    その文字列自体にマッチする部分で分割する。
#@else
: 1 バイトの文字列
      その文字を区切りとして分割する。
: 2 バイト以上の文字列
    [[m:Regexp.new]](sep) にマッチする文字列を区切りとして分割する。
#@end
: 1 バイトの空白文字 ' ' か nil
    先頭と末尾の空白を除いたうえで、空白文字列で分割する。
: 空文字列 '' あるいは空文字列にマッチする正規表現
    文字列を 1 文字ずつに分割する。マルチバイト文字を認識する。

sep が正規表現で、かつその正規表現に括弧が含まれている場合には、
各括弧のパターンにマッチした文字列も配列に含まれます。
括弧が複数ある場合は、マッチしたものだけが配列に含まれます。

第 2 引数 limit は以下のいずれかです。

: limit > 0
     最大 limit 個の文字列に分割する
: limit == 0
     分割個数制限はなしで、配列末尾の空文字列を取り除く
: limit < 0
     分割個数の制限はなし

@arg sep       文字列を分割するときのセパレータのパターン
@arg limit     分割する最大個数

例:
    p "   a \t  b \n  c".split(/\s+/) # => ["", "a", "b", "c"]

    p "   a \t  b \n  c".split(nil)   # => ["a", "b", "c"]
    p "   a \t  b \n  c".split(' ')   # => ["a", "b", "c"]   # split(nil) と同じ
    p "   a \t  b \n  c".split        # => ["a", "b", "c"]   # split(nil) と同じ

    # 括弧を含む正規表現
    p '1-10,20'.split(/([-,])/)   # => ["1", "-", "10", ",", "20"]

    # 正規表現が空文字列にマッチする場合は 1 文字に分割
    p 'hi there'.split(/\s*/).join(':')  # => "h:i:t:h:e:r:e"

    # 文字列全体を 1 文字ずつに分割する例
    p 'hi there'.split(//).join(':')     # => "h:i: :t:h:e:r:e"

    # $KCODE を設定すればマルチバイト文字列を認識
    $KCODE = "EUC"
    p '文字列'.split(//).join(':')       # => "文:字:列"

    # limit == 0 だと制限なく分割、配列末尾の空文字列は取り除かれる
    p "a,b,c,,,".split(/,/, 0)   # => ["a", "b", "c"]

    # limit 省略時は 0 と同じ (最もよく使われるパターン)
    p "a,b,c,,,".split(/,/)      # => ["a", "b", "c"]

    # 正の limit 使用例
    p "a,b,c,d,e".split(/,/, 1)  # => ["a,b,c,d,e"]
    p "a,b,c,d,e".split(/,/, 2)  # => ["a", "b,c,d,e"]
    p "a,b,c,d,e".split(/,/, 3)  # => ["a", "b", "c,d,e"]
    p "a,b,c,d,e".split(/,/, 4)  # => ["a", "b", "c", "d,e"]
    p "a,b,c,d,e".split(/,/, 5)  # => ["a", "b", "c", "d", "e"]
    p "a,b,c,d,e".split(/,/, 6)  # => ["a", "b", "c", "d", "e"]
    p "a,b,c,d,e".split(/,/, 7)  # => ["a", "b", "c", "d", "e"]

    # limit が負の数の場合は制限なく分割
    p "a,b,c,,,".split(/,/, -1)    # => ["a", "b", "c", "", "", ""]

--- squeeze(*chars) -> String

chars に含まれる文字が複数並んでいたら 1 文字にまとめます。

chars の形式は [[man:tr(1)]] と同じです。つまり、
`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外を意味します。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、`^' もその効果は文字列の先頭にあるときだけです。また、
`-', `^', `\' はバックスラッシュ(`\')によ
りエスケープすることができます。

引数を 1 つも指定しない場合は、すべての連続した文字を 1 文字にまとめます。

引数を複数指定した場合は、すべての引数にマッチする文字を 1 文字にまとめます。

例:
    p "112233445566778899".squeeze          # =>"123456789"
    p "112233445566778899".squeeze("2-8")   # =>"11234567899"

    # 以下の 2 つは同じ意味
    p "112233445566778899".squeeze("2378")          # =>"11234455667899"
    p "112233445566778899".squeeze("2-8", "^4-6")   # =>"11234455667899"

--- squeeze!(*chars) -> ()

chars に含まれる文字が複数並んでいたら 1 文字にまとめます。

chars の形式は [[man:tr(1)]] と同じです。つまり、
`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外を意味します。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、`^' もその効果は文字列の先頭にあるときだけです。また、
`-', `^', `\' はバックスラッシュ(`\')によ
りエスケープすることができます。

引数を 1 つも指定しない場合は、すべての連続した文字を 1 文字にまとめます。

引数を複数指定した場合は、すべての引数にマッチする文字を 1 文字にまとめます。

例:
    str = "112233445566778899"
    str.squeeze!
    p str    # =>"123456789"

    str = "112233445566778899"
    str.squeeze!("2-8")
    p str    # =>"11234567899"

--- strip -> String

文字列先頭と末尾の空白文字を全て取り除いた文字列を生成して返します。
空白文字の定義は " \t\r\n\f\v" です。
#@since 1.8.0
また、文字列右側からは "\0" も取り除きますが、
左側の "\0" は取り除きません。
#@end

例:
    p "  abc  \r\n".strip    #=> "abc"
    p "abc\n".strip          #=> "abc"
    p "  abc".strip          #=> "abc"
    p "abc".strip            #=> "abc"
#@since 1.8.0
    p "  \0  abc  \0".strip  # => "\000  abc"   # 右側のみ "\0" も取り除く
#@end

    str = "\tabc\n"
    p str.strip              #=> "abc"
    p str                    #=> "\tabc\n" (元の文字列は変化しない)

@see [[m:String#lstrip]]

--- strip! -> ()

先頭と末尾の空白文字を全て破壊的に取り除きます。
空白文字の定義は " \t\r\n\f\v" です。
#@since 1.8.0
また、文字列右側からは "\0" も取り除きますが、
左側の "\0" は取り除きません。
#@end

strip! は、内容を変更した self を返します。
ただし取り除く空白がなかったときは nil を返します。

例:

  str = "  abc\r\n"
  p str.strip!     #=> "abc"
  p str            #=> "abc"

  str = "abc"
  p str.strip!     #=> nil
  p str            #=> "abc"

#@since 1.8.0
  str = "  \0  abc  \0"
  str.strip!
  p str            # => "\000  abc"   # 右側の "\0" のみ取り除かれる
#@end

@see [[m:String#strip]], [[m:String#lstrip]]

#@since 1.8.0
--- lstrip -> String

文字列の先頭にある空白文字を全て取り除いた新しい文字列を返します。
空白文字の定義は " \t\r\n\f\v" です。

例:

  p "  abc\n".lstrip     #=> "abc\n"
  p "\t abc\n".lstrip    #=> "abc\n"
  p "abc\n".lstrip       #=> "abc\n"
#@end

#@since 1.8.0
--- lstrip! -> ()

文字列の先頭にある空白文字を全て破壊的に取り除きます。
空白文字の定義は " \t\r\n\f\v" です。

lstrip! は self を変更して返します。
ただし取り除く空白がなかったときは nil を返します。

例:
    str = "  abc"
    p str.lstrip!   # => "abc"
    p str           # => "abc"

    str = "abc"
    p str.lstrip!   # => nil
    p str           # => "abc"
#@end

#@since 1.8.0
--- rstrip -> String

文字列の末尾にある空白文字を全て取り除いた新しい文字列を返します。
空白文字の定義は " \t\r\n\f\v\0" です。

例:
    p "  abc\n".rstrip          #=> "  abc"
    p "  abc \t\r\n\0".rstrip   #=> "  abc"
    p "  abc".rstrip            #=> "  abc"

    str = "abc\n"
    p str.rstrip    #=> "abc"
    p str           #=> "abc\n"  (元の文字列は変化しない)

@see [[m:String#lstrip]]
#@end

#@since 1.8.0
--- rstrip! -> ()

文字列の末尾にある空白文字を全て破壊的に取り除きます。
空白文字の定義は " \t\r\n\f\v\0" です。

例:
    str = "  abc\n"
    p str.rstrip!   # => "  abc"
    p str           # => "  abc"

    str = "  abc \r\n\t\v\0"
    p str.rstrip!   # => "  abc"
    p str           # => "  abc"

@see [[m:String#rstrip]], [[m:String#lstrip]]
#@end

--- sub(pattern, replace) -> String

文字列中で pattern にマッチした最初の部分を
文字列 replace で置き換えた文字列を生成し返します。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

@arg pattern    置き換える文字列のパターン
@arg replace    pattern で指定した文字列と置き換える文字列

例:
    p 'abcdefg'.sub(/def/, '!!')          # => "abc!!g"
    p 'abcabc'.sub(/b/, '<<\&>>')         # => "a<<b>>cabc"
    p 'xxbbxbb'.sub(/x+(b+)/, 'X<<\1>>')  # => "X<<bb>>xbb"

注意:

第 2 引数 replace に [[m:$1]] を埋め込んでも意図した結果にはなりません。
この文字列が評価される時点ではまだ正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、sub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

    # ひとつめの括弧の内容に置き換えるときによくある間違い
    p 'xbbb-xbbb'.sub(/x(b+)/, "#{$1}")   # => "-xbbb"     # NG
    p 'xbbb-xbbb'.sub(/x(b+)/, "\1")      # => "1-xbbb"    # NG
    p 'xbbb-xbbb'.sub(/x(b+)/, "\\1")     # => "bbb-xbbb"  # OK
    p 'xbbb-xbbb'.sub(/x(b+)/, '\1')      # => "bbb-xbbb"  # OK
    p 'xbbb-xbbb'.sub(/x(b+)/, '\\1')     # => "bbb-xbbb"  # OK

    # バックスラッシュを倍にするときによくある間違い
    puts '\n'.sub(/\\/, "\\\\")      # => \n   # NG
    puts '\n'.sub(/\\/, '\\\\')      # => \n   # NG
    puts '\n'.sub(/\\/, "\\\\\\\\")  # => \\n  # OK
    puts '\n'.sub(/\\/, '\\\\\\\\')  # => \\n  # OK

このような間違いを確実に防止し、コードの可読性を上げるには、
\& や \1 よりも下記のようにブロック付き形式の sub を使うべきです。

    p 'xbbb-xbbb'.sub(/x(b+)/) { $1 }   # => "bbb-xbbb"  # OK

    puts '\n'.sub(/\\/) { '\\\\' }      # => \\n        # OK

@see [[m:String#gsub]]

--- sub(pattern) {|matched| .... } -> String

文字列中で pattern にマッチした最初の部分をブロックに渡し、
その評価結果で置き換えた新しい文字列を返します。
ブロックなしの sub と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

@arg pattern    置き換える文字列のパターン

例:

    p 'abcabc'.sub(/b/) {|s| s.upcase }  #=> "aBcabc"
    p 'abcabc'.sub(/b/) { $&.upcase }    #=> "aBcabc"

@see [[m:String#gsub]]

--- sub!(pattern, replace) -> ()

文字列中で pattern にマッチした最初の部分を文字列 replace へ破壊的に置き換えます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

置換文字列 replace 中の \& と \0 はマッチした部分文字列に、
\1 ... \9 は n 番目の括弧の内容に置き換えられます。
置換文字列内では \`、\'、\+ も使えます。
これらは [[m:$`]]、[[m:$']]、[[m:$+]] に対応します。

sub! は通常 self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@arg pattern    置き換える文字列のパターン
@arg replace    pattern で指定した文字列と置き換える文字列

例:

    buf = "String-String"
    buf.sub!(/in./, "!!")
    p buf   # => "Str!!-String"

    buf = "String.String"
    buf.sub!(/in./, '<<\&>>')
    p buf   # => "Str<<ing>>-String"

注意:

引数 replace の中で [[m:$1]] を使うことはできません。
replace は sub メソッドの呼び出しより先に評価されるので、
まだ sub の正規表現マッチが行われておらず、
$1 がセットされていないからです。

また、sub では「\」が部分文字列との置き換えという特別な意味を持つため、
replace に「\」自身を入れたいときは
「\」を二重にエスケープしなければなりません。

例:
    # ひとつめの括弧にマッチした部分に置き換えるときによくやる間違い
    'abbbcd'.sub!(/a(b+)/, "#{$1}")       # NG
    'abbbcd'.sub!(/a(b+)/, "\1")          # NG
    'abbbcd'.sub!(/a(b+)/, "\\1")         # OK
    'abbbcd'.sub!(/a(b+)/, '\\1')         # OK
    'abbbcd'.sub!(/a(b+)/, '\1')          # OK
    'abbbcd'.sub!(/a(b+)/) { $1 }         # OK   これがもっとも安全

@see [[m:String#gsub]]

--- sub!(pattern) {|matched| .... } -> ()

文字列中で pattern にマッチした最初の部分をブロックに渡し、
その評価結果へ破壊的に置き換えます。

Ruby 1.6 以前では pattern が文字列の場合、
その文字列を正規表現にコンパイルしていました。
しかし Ruby 1.8 以降では、その文字列そのものがパターンになります。

また、ブロックなしの sub と違い、ブロックの中からは
組み込み変数 [[m:$1]], $2, $3, ... を問題なく参照できます。

@arg pattern    置き換える文字列のパターン

例:
    str = 'abcabc'
    str.sub!(/b/) {|s| s.upcase }
    p str    #=> "aBcabc"

    str = 'abcabc'
    str.sub!(/b/) { $&.upcase }
    p str    #=> "aBcabc"

@see [[m:String#gsub]]

--- sum(bits = 16) -> Integer

文字列の bits ビットのチェックサムを計算します。
以下と同じです。

   def sum(bits)
     sum = 0
     each_byte {|c| sum += c }
     return 0 if sum == 0
     sum & ((1 << bits) - 1)
   end

例えば以下のコードで UNIX System V の
[[man:sum(1)]] コマンドと同じ値が得られます。

例:
    sum = 0
    ARGF.each_line do |line|
      sum += line.sum
    end
    sum %= 65536

@arg bits    チェックサムのビット数

--- swapcase -> String

全てのアルファベット大文字を小文字に、
小文字を大文字に変更した文字列を返します。

このメソッドはマルチバイト文字を認識しません。
そのため、文字列が Shift JIS エンコーディングで、
かつ [[m:$KCODE]] が適切に設定されていない場合、
マルチバイト文字の一部も変換してしまう場合があります。
逆に、[[m:$KCODE]] を設定しても
マルチバイト文字のアルファベットは処理しません。

例:
    p "ABCxyz".swapcase   # => "abcXYZ"
    p "Access".swapcase   # => "aCCESS"

    # -*- Coding: shift_jis -*-
    $KCODE = 'n'
    puts "蟻".swapcase   # => 帰

@see [[m:String#upcase]], [[m:String#downcase]], [[m:String#capitalize]]

--- swapcase! -> ()

全ての大文字を小文字に、小文字を大文字に、破壊的に変更します。

swapcase! は self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

このメソッドはマルチバイト文字を認識しません。
そのため、文字列が Shift JIS エンコーディングで、
かつ [[m:$KCODE]] が適切に設定されていない場合、
マルチバイト文字の一部も変換してしまう場合があります。
逆に、[[m:$KCODE]] を設定しても
マルチバイト文字のアルファベットは処理しません。

例:
    str = "ABCxyz"
    str.swapcase!
    p str   # => "abcXYZ"

    # -*- Coding: shift_jis -*-
    $KCODE ='n'
    puts "蟻".swapcase   # => 帰

@see [[m:String#upcase]], [[m:String#downcase]], [[m:String#capitalize]]

--- to_f -> Float

文字列を 10 進数表現と解釈して、浮動小数点数 [[c:Float]] に変換します。

浮動小数点数とみなせなくなるところまでを変換対象とします。
変換対象が空文字列であれば 0.0 を返します。

例:

  p "10".to_f    # => 10.0
  p "10e2".to_f  # => 1000.0
  p "1e-2".to_f  # => 0.01
  p ".1".to_f    # => 0.1

  p "nan".to_f   # => 0.0
  p "INF".to_f   # => 0.0
  p "-Inf".to_f  # => -0.0
  p(("10" * 1000).to_f)   # => Infinity (with warning)

  p "".to_f      # => 0.0
  p "1_0_0".to_f # => 100.0
  p " \n10".to_f # => 10.0       # 先頭の空白は無視される
  p "0xa.a".to_f # => 0.0

なお、このメソッドの逆に、数値を文字列に変換するには
[[m:Kernel.#sprintf]],[[m:String#%]],[[m:Integer#to_s]]
を使用します。

@see [[m:String#hex]], [[m:String#oct]], [[m:String#to_i]],
     [[m:Kernel.#Integer]], [[m:Kernel.#Float]]

--- to_i(base = 10) -> Integer

文字列を 10 進数表現された整数であると解釈して、整数に変換します。

  p " 10".to_i    # => 10
  p "+10".to_i    # => 10
  p "-10".to_i    # => -10

  p "010".to_i    # => 10
  p "-010".to_i   # => -10

整数とみなせない文字があればそこまでを変換対象とします。
変換対象が空文字列であれば 0 を返します。

  p "0x11".to_i   # => 0
  p "".to_i       # => 0

#@since 1.8.0
基数を指定することでデフォルトの 10 進以外に 2 〜 36 進数表現へ変換できます。
それぞれ Ruby の整数リテラルで使用可能なプリフィクスは無視されます。
また、base に 0 を指定するとプリフィクスから基数を判断します。
認識できるプリフィクスは、
0b (2 進数)、0 (8 進数)、0o (8 進数)、0d (10 進数)、0x (16 進数) です。

0, 2 〜 36 以外の引数を指定した場合は
例外 [[c:ArgumentError]] が発生します。

  p "01".to_i(2)    # => 1
  p "0b1".to_i(2)   # => 1

  p "07".to_i(8)    # => 7
  p "0o7".to_i(8)   # => 7

  p "1f".to_i(16)   # => 31
  p "0x1f".to_i(16) # => 31

  p "0b10".to_i(0)  # => 2
  p "0o10".to_i(0)  # => 8
  p "010".to_i(0)   # => 8
  p "0d10".to_i(0)  # => 10
  p "0x10".to_i(0)  # => 16
#@end

@param base    進数を指定する整数。0 か、2〜36 の整数。
@return        整数

このメソッドの逆に数値を文字列に変換するには、
[[m:Kernel.#sprintf]], [[m:String#%]], [[m:Integer#to_s]]
を使用します。

[[m:String#hex]], [[m:String#oct]], [[m:String#to_f]],
[[m:Kernel.#Integer]], [[m:Kernel.#Float]]
も参照してください。

--- to_s -> String
--- to_str -> String

self を返します。

例:

    p "str".to_s     # => "str"
    p "str".to_str   # => "str"

このメソッドは、文字列を他のクラスのインスタンスと混ぜて処理したいときに有効です。
例えば返り値が文字列か nil であるメソッド some_method があるとき、
to_s メソッドを使うと以下のように統一的に処理できます。

    # some_method(5).downcase だと返り値が nil のときに
    # エラーになるので to_s をはさむ
    p some_method(5).to_s.downcase

--- tr(pattern, replace) -> String

pattern 文字列に含まれる文字を検索し、
それを replace 文字列の対応する文字に置き換えます。

search の形式は [[man:tr(1)]] と同じです。つまり、
`a-c' は a から c を意味し、"^0-9" のように
文字列の先頭が `^' の場合は指定文字以外が置換の対象になります。

replace に対しても `-' による範囲指定が可能です。
例えば [[m:String#upcase]] は tr を使って
"foo".tr('a-z', 'A-Z') と書けます。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
`^' も文字列の先頭にあるときにだけ否定の効果を発揮します。
また、`-', `^', `\' はバックスラッシュ (`\') によりエスケープできます。

replace の範囲が pattern の範囲よりも小さい場合は、
replace の最後の文字が無限に続くものとして扱われます。

@arg pattern    置き換える文字のパターン
@arg replace    pattern で指定した文字を置き換える文字

例:
    p "foo".tr("f", "X")      # => "Xoo"
    p "foo".tr('a-z', 'A-Z')  # => "FOO"
    p "FOO".tr('A-Z', 'a-z')  # => "foo"

@see [[m:String#tr_s]]

--- tr!(pattern, replace) -> ()

pattern 文字列に含まれる文字を検索し、
それを replace 文字列の対応する文字に破壊的に置き換えます。

pattern の形式は [[man:tr(1)]] と同じです。
つまり、`a-c' は a から c を意味し、
"^0-9" のように文字列の先頭が `^' の場合は
指定文字以外が置換の対象になります。

replace に対しても `-' による範囲指定が可能です。
例えば、[[m:String#upcase]] を tr で書くと、

  p "foo".tr('a-z', 'A-Z')
  => "FOO"

となります。

`-' は文字列の両端にない場合にだけ範囲指定の意味になります。
`^' も文字列の先頭にあるときにだけ否定の効果を発揮します。
また、`-', `^', `\' はバックスラッシュ (`\') によりエスケープできます。

replace の範囲が pattern の範囲よりも小さい場合は、
replace の最後の文字が無限に続くものと扱われます。

tr! は self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

@arg pattern    置き換える文字のパターン
@arg replace    pattern で指定した文字を置き換える文字

@see [[m:String#tr]], [[m:String#tr_s]]

--- tr_s(pattern, replace) -> String

文字列の中に pattern 文字列に含まれる文字が存在したら、
replace 文字列の対応する文字に置き換えます。さらに、
置換した部分内に同一の文字の並びがあったらそれを 1 文字に圧縮します。

pattern の形式は [[man:tr(1)]] と同じです。
つまり「a-c」は a から c を意味し、
"^0-9" のように文字列の先頭が「^」の場合は指定した文字以外が置換の対象になります。

replace でも「-」を使って範囲を指定できます。

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、「^」もその効果は文字列の先頭にあるときだけです。
また、「-」、「^」、「\」はバックスラッシュ (「\」) でエスケープできます。

replace の範囲が pattern の範囲よりも小さい場合、
replace の最後の文字が無限に続くものとして扱われます。

@arg pattern    置き換える文字のパターン
@arg replace    pattern で指定した文字を置き換える文字

例:
    p "gooooogle".tr_s("o", "X")       # => "gXgle"
    p "gooooogle".tr_s("a-z", "A-Z")   # => "GOGLE"

注意:
一般に、tr_s を tr と squeeze で置き換えることはできません。
tr と squeeze の組みあわせでは tr の置換後の文字列全体を squeeze しますが、
tr_s は置換された部分だけを squeeze します。
以下のコードを参照してください。

    p "foo".tr_s("o", "f")              # => "ff"
    p "foo".tr("o", "f").squeeze("f")   # => "f"

@see [[m:String#tr]]

--- tr_s!(pattern, replace) -> ()

文字列の中に pattern 文字列に含まれる文字が存在したら、
replace 文字列の対応する文字に置き換えます。さらに、
置換した部分内に同一の文字の並びがあったらそれを 1 文字に圧縮します。

pattern の形式は [[man:tr(1)]] と同じです。
つまり「a-c」は a から c を意味し、
"^0-9" のように文字列の先頭が「^」の場合は指定した文字以外が置換の対象になります。

replace でも「-」を使って範囲を指定できます。

  p "gooooogle".tr_s("a-z", "A-Z")   # => "GOGLE"

「-」は文字列の両端にない場合にだけ範囲指定の意味になります。
同様に、「^」もその効果は文字列の先頭にあるときだけです。
また、「-」、「^」、「\」はバックスラッシュ (「\」) でエスケープできます。

replace の範囲が search の範囲よりも小さい場合、
replace の最後の文字が無限に続くものとして扱われます。

tr_s は置換後の文字列を生成して返します。
tr_s! は self を変更して返しますが、
置換が起こらなかった場合は nil を返します。

注意:
一般に、tr_s! を tr! と squeeze! で置き換えることはできません。
tr! と squeeze! の組みあわせでは tr! の置換後の文字列全体を squeeze! しますが、
tr_s! は置換された部分だけを squeeze! します。
以下のコードを参照してください。

    str = "foo"
    str.tr_s!("o", "f")
    p str   # => "ff"

    str = "foo"
    str.tr!("o", "f")
    str.squeeze!("f")
    p str   # => "f"

@arg pattern    置き換える文字のパターン
@arg replace    pattern で指定した文字を置き換える文字

@see [[m:String#tr]], [[m:String#tr_s]]

--- unpack(template) -> Array

[[m:Array#pack]] で生成された文字列を
テンプレート文字列 template にしたがってアンパックし、
それらの要素を含む配列を返します。

@param template    pack テンプレート文字列
@return            オブジェクトの配列

#@include(pack-template)

--- upcase -> String

すべてのアルファベットを大文字に変換した文字列を作成し返します。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。

また、マルチバイト文字列に対応するためには
[[m:$KCODE]] を設定する必要があります。
文字列が Shift JIS エンコーディングで
[[m:$KCODE]] が適切に設定されていないときは
以下のようにマルチバイト文字の一部も変換してしまいます。

  # ソースコードは Shift JIS エンコーディングとする
  $KCODE = "SJIS"
  puts "蟻".upcase   # => 蟻   ($KCODE が適切なので正しく無視された)

  $KCODE = "NONE"
  puts "蟻".upcase   # => 帰   ($KCODE が不適切なので誤って処理された)

例:
    p "stRIng? STring.".upcase   # => "STRING? STRING."

@see [[m:String#upcase!]], [[m:String#downcase]],
     [[m:String#swapcase]], [[m:String#capitalize]]

--- upcase! -> ()

ASCII 文字列の範囲内でアルファベットを全て大文字にします。
このメソッドは self を破壊的に変更して返しますが、
置換が起こらなかった場合は nil を返します。

このメソッドはマルチバイト文字列を認識しますが、
それはあくまでも「1 文字を 1 文字として認識する」だけであって、
いわゆる全角アルファベットの大文字小文字までは変換しません。

また、マルチバイト文字列に対応するためには
[[m:$KCODE]] を設定する必要があります。
文字列が Shift JIS エンコーディングで
[[m:$KCODE]] が適切に設定されていないときは
以下のようにマルチバイト文字の一部も変換してしまいます。

  # ソースコードは Shift JIS エンコーディングとする
  $KCODE = "SJIS"
  str = "蟻"
  str.upcase!
  puts str   # => 蟻   ($KCODE が適切なので正しく無視された)

  $KCODE = "NONE"
  str = "蟻"
  str.upcase!
  puts str   # => 帰   ($KCODE が不適切なので誤って処理された)

例:
    buf = "stRIng? STring."
    buf.upcase!
    p buf   # => "STRING? STRING."

@see [[m:String#upcase]], [[m:String#downcase!]],
     [[m:String#swapcase!]], [[m:String#capitalize!]]

--- upto(max) {|s| ... } -> ()

self から始めて max まで
「次の文字列」を順番にブロックに与えて繰り返します。
「次」の定義については [[m:String#succ]] を参照してください。

たとえば以下のコードは a, b, c, ... z, aa, ... az, ..., za を
出力します。

  ("a" .. "za").each do |str|
    puts str
  end

@arg max    繰り返しをやめる文字列

--- eql?(other) -> bool

self == other と同じです。
[[c:Hash]] クラス内での比較に使われます。

@see [[c:Hash]]

--- hash -> Integer

self のハッシュ値を返します。
eql? で等しい文字列は、常にハッシュ値も等しくなります。

@see [[c:Hash]]

--- inspect -> String

Ruby のリテラル形式を使って、
文字列中の不可視文字をエスケープシーケンスに変換します。

$KCODE が設定されている場合は、
そのエンコーディング内の適正なマルチバイト文字をそのまま出力します。
それ以外の不可視文字はエスケープシーケンスを使って出力されます。

このメソッドは主にデバッグのために用意されています。
永続化などの目的で文字列をダンプしたいときは、
[[m:String#dump]] を使うべきです。

例：

  # p ではないことに注意
  puts "string".inspect    # => "string"
  puts "\t\r\n".inspect    # => "\t\r\n"

@see [[m:String#dump]]

#@since 1.9.0
--- chr -> String

self の最初の文字だけを含む文字列を返します。

@see [[m:String#ord]], [[m:Integer#chr]]

--- start_with?(str) -> bool

self の先頭が str であるとき true を返します。

@arg str    パターンを表す文字列

例:
    "string".end_with?("str")   # => true
    "string".end_with?("ing")   # => false

@see [[m:String#end_with?]]

--- end_with?(str) -> bool

self の末尾が str であるとき true を返します。

@arg str    パターンを表す文字列

例:
    "string".end_with?("ing")   # => true
    "string".end_with?("str")   # => false

@see [[m:String#start_with?]]

--- lines -> Enumerable::Enumerator

文字列を行の配列 (を生成する Enumerator) に変換します。

例:
    p "aa\nbb\ncc\n".lines.to_a   # => ["aa\n", "bb\n", "cc\n"]
    p "aa\n".lines.to_a           # => ["aa\n"]
    p "".lines.to_a               # => []

--- ord -> Integer

文字列の最初の文字の文字コードを返します。

self が空文字列のときは例外 TypeError を発生します。

@return             文字コードを表す整数
@raise TypeError    self の長さが 0 のとき発生

例:
    p "a".ord   # => 97

@see [[m:Integer#chr]], [[m:String#chr]]

--- partition(sep) -> [String, String, String]

セパレータ sep が最初に登場する部分で self を 2 つに分割し、
[セパレータを含まない先頭部分, セパレータ, それ以降の部分]
の 3 要素の配列を返します。

self がセパレータを含まないときは、
返り値の第 2 要素と第 3 要素が空文字列になります。

@arg sep    セパレータを表す文字列か正規表現

例：

  p "axaxa".partition("x")   # => ["a", "x", "axa"]
  p "aaaaa".partition("x")   # => ["aaaaa", "", ""]

@see [[m:String#rpartition]], [[m:String#split]]

--- rpartition(sep) -> [String, String, String]

セパレータ sep が最後に登場する部分で self を 2 つに分割し、
[最後のセパレータより前の部分, セパレータ, それ以降の部分]
の 3 要素の配列を返します。

self がセパレータを含まないときは、
返り値の第 2 要素と第 3 要素が空文字列になります。

@arg sep    セパレータを表す文字列か正規表現

例：

  p "axaxa".partition("x")   # => ["axa", "x", "a"]
  p "aaaaa".partition("x")   # => ["", "", "aaaaa"]

@see [[m:String#partition]], [[m:String#split]]
#@end

#@since 1.9.0
--- bytesize
#@todo

--- each_char {|cstr| block }    -> String
#@todo

Passes each character in str to the given block.

   "hello".each_char {|c| print c, ' ' }

produces:

   h e l l o

--- encoding   -> Encoding
#@todo

Returns the Encoding object that represents the encoding of obj.

--- force_encoding(encoding)   -> String
#@todo

Changes the encoding to encoding and returns self.

--- ~
#@todo

#@end
